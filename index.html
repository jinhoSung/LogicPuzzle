<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Logic Node v12.4: Paper Crunch Sound</title>
    <style>
        :root {
            --bg: #1e1e1e;
            --panel: #252526;
            --accent: #007acc;
            --text: #cccccc;
            --red: #ff5555;
            --blue: #55aaff;
            --green: #50fa7b;
            --yellow: #f1fa8c;
            --purple: #bd93f9;
            --gold: #ffd700;
            --power: #00d2ff;
            --cpu: #ff9900;
        }
        body {
            margin: 0; background-color: var(--bg); color: var(--text);
            font-family: 'Segoe UI', monospace; overflow: hidden;
            display: flex; flex-direction: column; height: 100vh;
            user-select: none;
        }

        /* í—¤ë” ìŠ¤íƒ€ì¼ */
        header {
            height: 60px; background: var(--panel); border-bottom: 1px solid #333;
            display: flex; align-items: center; padding: 0 25px;
            justify-content: space-between; box-shadow: 0 4px 10px rgba(0,0,0,0.3); z-index: 10;
        }
        .header-title { font-size: 1.3rem; font-weight: 800; color: white; letter-spacing: 1px; }
        .header-info { display: flex; gap: 15px; align-items: center; }
        
        .stat-item {
            font-family: 'Consolas', monospace; font-size: 0.95rem; 
            color: #ccc; background: rgba(0,0,0,0.3); padding: 8px 15px; 
            border-radius: 6px; border: 1px solid #444; display: flex; align-items: center;
        }
        .stat-label { color: #888; margin-right: 8px; font-size: 0.85em; font-weight: bold; }

        /* ê²Œì´ì§€ ë°” */
        .power-meter-box { width: 120px; height: 8px; background: #111; border-radius: 4px; overflow: hidden; margin-left: 10px; }
        .power-fill { height: 100%; background: linear-gradient(90deg, var(--power), #0077ff); width: 0%; transition: width 0.3s; }
        
        #funds-display { color: var(--gold); font-weight: bold; font-size: 1.1em; }
        #cpu-display { color: var(--cpu); font-weight: bold; font-size: 1.1em; text-shadow: 0 0 5px rgba(255, 153, 0, 0.3); }

        /* ë©”ì¸ ì˜ì—­ */
        #main { display: flex; flex: 1; }

        /* íˆ´ë°•ìŠ¤ */
        #toolbox {
            width: 260px; background: #2d2d30; border-right: 1px solid #333;
            padding: 15px; display: flex; flex-direction: column; gap: 12px;
            z-index: 5; overflow-y: auto;
        }
        .node-item {
            background: #3e3e42; padding: 12px; border-radius: 8px;
            cursor: pointer; border: 1px solid #555; transition: all 0.2s ease;
            position: relative; box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .node-item:hover { background: #505050; border-color: var(--power); transform: translateX(5px); }
        .node-name { font-weight: bold; color: #fff; font-size: 0.95rem; }
        .node-desc { display: block; color: #bbb; font-size: 0.75em; margin-top: 4px; }
        .node-meta { display: flex; justify-content: flex-end; margin-top: 8px; font-size: 0.9em; font-weight: bold; }
        .node-tag { position: absolute; top: 10px; right: 10px; font-size: 0.65em; padding: 2px 6px; border-radius: 4px; background: #555; color: #fff; }
        .tag-ai { background: var(--purple); color: #222; }

        /* ìº”ë²„ìŠ¤ */
        #canvas-container {
            flex: 1; position: relative; background-color: #222;
            background-image: linear-gradient(rgba(255,255,255,0.03) 1px, transparent 1px), linear-gradient(90deg, rgba(255,255,255,0.03) 1px, transparent 1px);
            background-size: 40px 40px; overflow: hidden;
        }
        canvas { display: block; width: 100%; height: 100%; cursor: crosshair; }

        /* ì»¨íŠ¸ë¡¤ ë° UI */
        #controls { position: absolute; bottom: 30px; right: 30px; display: flex; gap: 10px; }
        .action-btn {
            background: var(--accent); color: white; border: none; padding: 12px 24px;
            font-size: 1rem; cursor: pointer; border-radius: 6px; font-weight: bold;
            transition: 0.2s; box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        .action-btn:hover { filter: brightness(1.1); transform: translateY(-2px); }
        .btn-stop { background: var(--red); }
        .btn-retry { background: #4caf50; }
        .btn-clear { background: #444; }
        .btn-store { background: var(--gold); color: #222; }

        #toast {
            position: absolute; top: 80px; left: 50%; transform: translateX(-50%);
            background: rgba(255, 68, 68, 0.9); color: white; padding: 10px 20px;
            border-radius: 20px; font-weight: bold; opacity: 0; pointer-events: none; transition: opacity 0.3s; z-index: 100;
        }

        /* ëª¨ë‹¬ ê³µí†µ */
        .modal-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); display: flex; justify-content: center; align-items: center;
            z-index: 100; backdrop-filter: blur(5px); display: none;
        }
        .modal-content {
            background: #252526; border: 1px solid #555; padding: 40px;
            border-radius: 12px; max-width: 500px; text-align: center;
            box-shadow: 0 20px 50px rgba(0,0,0,0.8);
        }
        .modal-title { font-size: 1.8rem; margin: 0 0 20px 0; color: white; }
        .modal-text { font-size: 1rem; line-height: 1.6; color: #ddd; margin-bottom: 30px; text-align: left; }
        .highlight { color: var(--yellow); font-weight: bold; background: rgba(255,255,0,0.1); padding: 0 4px; }

        /* ìƒì  */
        #store-modal .modal-content { border: 2px solid var(--gold); width: 450px; }
        .upgrade-item {
            display: flex; justify-content: space-between; align-items: center;
            background: #333; padding: 15px; margin-bottom: 10px; border-radius: 8px; border: 1px solid #444; text-align: left;
        }
        .up-btn { background: var(--gold); color: #222; border: none; padding: 8px 12px; border-radius: 4px; font-weight: bold; cursor: pointer; }
        .up-btn:disabled { background: #555; color: #888; cursor: not-allowed; }
    </style>
</head>
<body>

<header>
    <div class="header-title">LOGIC NODE v12.4</div>
    <div class="header-info">
        <div class="stat-item" style="border-color: var(--gold);">
            <span class="stat-label">MONEY</span>$<span id="funds-display">0</span>
        </div>
        <div class="stat-item" style="border-color: var(--cpu);">
            <span class="stat-label">CPU CLOCK</span><span id="cpu-display">1.0 GHz</span>
        </div>
        <div class="stat-item" style="border-color: var(--power);">
            <span class="stat-label">POWER</span>
            <div class="power-meter-box"><div class="power-fill" id="power-bar"></div></div>
            <span style="font-size:0.8em; margin-left:8px; font-weight:bold; color:var(--power)">
                <span id="power-current">0</span>/<span id="power-max">50</span>W
            </span>
        </div>
        <div class="stat-item">
            <span class="stat-label">GOAL</span><span id="goal-status" style="color:white; font-weight:bold;">...</span>
        </div>
    </div>
</header>

<div id="toast">ì•Œë¦¼</div>

<!-- ìƒì  -->
<div id="store-modal" class="modal-overlay">
    <div class="modal-content">
        <div style="text-align:right; margin-bottom:-20px;"><span onclick="game.closeStore()" style="cursor:pointer; color:#aaa; font-size:1.5rem;">âœ•</span></div>
        <h2 style="color:var(--gold); margin-top:0;">ğŸ› ï¸ Hardware Store</h2>
        <div class="upgrade-item">
            <div><h4 style="margin:0; color:white">Power Supply</h4><p style="margin:0; font-size:0.8em; color:#aaa">+30 Max Power</p></div>
            <button class="up-btn" id="btn-up-power" onclick="game.buyUpgrade('POWER')">$200</button>
        </div>
        <div class="upgrade-item">
            <div><h4 style="margin:0; color:white">Overclocking</h4><p style="margin:0; font-size:0.8em; color:#aaa">+0.2 GHz CPU Clock</p></div>
            <button class="up-btn" id="btn-up-speed" onclick="game.buyUpgrade('SPEED')">$300</button>
        </div>
    </div>
</div>

<div id="main">
    <div id="toolbox">
        <!-- ë…¸ë“œ ëª©ë¡ JS ìƒì„± -->
    </div>
    
    <div id="canvas-container">
        <canvas id="gameCanvas"></canvas>
        <div id="controls">
            <button class="action-btn btn-store" onclick="game.openStore()">ğŸ›’ ìƒì </button>
            <button class="action-btn btn-clear" onclick="game.resetLevel()">ğŸ—‘ï¸ ì´ˆê¸°í™”</button>
            <button class="action-btn btn-retry" onclick="game.retrySim()">â†º ì¬ì‹œë„</button>
            <button class="action-btn" onclick="game.toggleRun()" id="run-btn">â–¶ ì‹¤í–‰</button>
        </div>
        
        <!-- ë¯¸ì…˜ ë¸Œë¦¬í•‘ -->
        <div id="mission-modal" class="modal-overlay" style="display:flex;">
            <div class="modal-content">
                <h2 class="modal-title" id="m-title">Level 1</h2>
                <div class="modal-text" id="m-desc">ë¡œë”© ì¤‘...</div>
                <button class="action-btn" onclick="game.closeModal()">ì„¤ê³„ ì‹œì‘</button>
            </div>
        </div>
    </div>
</div>

<script>
/**
 * ğŸ”Š ì˜¤ë””ì˜¤ ì‹œìŠ¤í…œ
 */
const AudioSys = {
    ctx: null,
    noiseBuffer: null,
    init() { 
        if (!this.ctx) { 
            this.ctx = new (window.AudioContext || window.webkitAudioContext)(); 
            // ë°±ìƒ‰ ì†ŒìŒ ë²„í¼ ìƒì„±
            const bufferSize = this.ctx.sampleRate * 0.5; 
            const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            this.noiseBuffer = buffer;
        } 
        if (this.ctx.state === 'suspended') { this.ctx.resume(); } 
    },
    playTone(type) {
        if (!this.ctx) return;
        const now = this.ctx.currentTime;
        
        if (type === 'trash') { 
            // ğŸ—‘ï¸ íœ´ì§€í†µ ì‚¬ìš´ë“œ: ì¢…ì´ êµ¬ê¸°ëŠ” ì†Œë¦¬ (ë°”ìŠ¤ë½)
            if (this.noiseBuffer) {
                const src = this.ctx.createBufferSource();
                src.buffer = this.noiseBuffer;
                // ì¬ìƒ ì†ë„ë¥¼ ëœë¤í•˜ê²Œ í•˜ì—¬ ë§¤ë²ˆ ë‹¤ë¥¸ êµ¬ê¹€ ì†Œë¦¬
                src.playbackRate.value = 0.8 + Math.random() * 0.4;

                const filter = this.ctx.createBiquadFilter();
                filter.type = 'bandpass'; // ëŒ€ì—­ í†µê³¼ (ë°”ìŠ¤ë½ ê±°ë¦¬ëŠ” ëŒ€ì—­)
                filter.frequency.value = 1000 + Math.random() * 500; 
                filter.Q.value = 0.5;

                const gain = this.ctx.createGain();
                // ì§§ê³  ê°•ë ¬í•œ ë°”ìŠ¤ë½
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(1.5, now + 0.02);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
                
                src.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);
                
                src.start(now);
                src.stop(now + 0.3);
            }
            // íƒ€ê²©ìŒ(ì¿µ)ì€ ì œê±°ë¨
            
        } else if (type === 'spawn') {
            const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
            osc.connect(gain); gain.connect(this.ctx.destination);
            osc.type = 'sine'; osc.frequency.setValueAtTime(600, now); osc.frequency.exponentialRampToValueAtTime(300, now + 0.1);
            gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
            osc.start(now); osc.stop(now + 0.1);
        } else if (type === 'success') {
            const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
            osc.connect(gain); gain.connect(this.ctx.destination);
            osc.type = 'square'; osc.frequency.setValueAtTime(1200, now); osc.frequency.setValueAtTime(1600, now + 0.1);
            gain.gain.setValueAtTime(0.05, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
            osc.start(now); osc.stop(now + 0.3);
        } else if (type === 'fail') {
            const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
            osc.connect(gain); gain.connect(this.ctx.destination);
            osc.type = 'sawtooth'; 
            osc.frequency.setValueAtTime(100, now); osc.frequency.linearRampToValueAtTime(50, now + 0.5);
            gain.gain.setValueAtTime(0.2, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
            osc.start(now); osc.stop(now + 0.5);
        } else if (type === 'click') {
            const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
            osc.connect(gain); gain.connect(this.ctx.destination);
            osc.type = 'triangle'; osc.frequency.setValueAtTime(800, now);
            gain.gain.setValueAtTime(0.05, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
            osc.start(now); osc.stop(now + 0.05);
        } else if (type === 'clear') {
            this.playNote(523.25, now, 0.1); this.playNote(659.25, now+0.1, 0.1); this.playNote(783.99, now+0.2, 0.2); this.playNote(1046.50, now+0.3, 0.4);
        }
    },
    playNote(freq, time, dur) {
        const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
        osc.connect(gain); gain.connect(this.ctx.destination);
        osc.frequency.value = freq; gain.gain.setValueAtTime(0.1, time); gain.gain.exponentialRampToValueAtTime(0.01, time+dur);
        osc.start(time); osc.stop(time+dur);
    }
};

/**
 * ğŸ› ï¸ ê²Œì„ ë°ì´í„°
 */
const COLORS = { RED:'#ff5555', BLUE:'#55aaff', GREEN:'#50fa7b', YELLOW:'#f1fa8c' };
const SHAPES = { CIRCLE:0, SQUARE:1, TRIANGLE:2 };

// ğŸ› ï¸ ë…¸ë“œ ì •ì˜: cost ì œê±°ë¨
const NODE_TYPES = {
    FILTER: { name: "Color Filter", desc: "ìƒ‰ìƒ ë¶„ë¥˜", power: 5, tag: "Basic" },
    SHAPE_SORTER: { name: "Shape Sorter", desc: "ëª¨ì–‘ ë¶„ë¥˜", power: 8, tag: "Shape" },
    PERCEPTRON: { name: "Perceptron AI", desc: "í•™ìŠµí˜• ë¶„ë¥˜ê¸°", power: 15, tag: "AI" },
    BALANCER: { name: "Balancer", desc: "ë¶€í•˜ ë¶„ì‚°", power: 3, tag: "Util" },
    TRASH: { name: "Trash", desc: "ë°ì´í„° ì‚­ì œ", power: 1, tag: "Util" }
};

const UPGRADE_COSTS = { POWER: 200, SPEED: 300 };

const LEVELS = [
    {
        id: 1, title: "ë°ì´í„° ì •ì œì˜ ê¸°ì´ˆ", grant: 0, power: 50, reward: 10,
        desc: "<strong>ëª©í‘œ:</strong> ë„¤ëª¨(Square) 5ê°œ ìˆ˜ì§‘.<br>ë…¸ë“œ ë°°ì¹˜ëŠ” <strong>ë¬´ë£Œ</strong>ì…ë‹ˆë‹¤. ì „ë ¥(Power) í•œë„ ë‚´ì—ì„œ ì„¤ê³„í•˜ì„¸ìš”.<br>ì„œë²„ê°€ ì›í•˜ì§€ ì•ŠëŠ” ë°ì´í„°ê°€ ë“¤ì–´ê°€ë©´ <strong>ì‘ì „ ì‹¤íŒ¨</strong>ì…ë‹ˆë‹¤.",
        preset: [
            { type: 'SOURCE', x: 100, y: 300, props: { spawnList: [{color:'RED', shape:'CIRCLE', count:5}, {color:'BLUE', shape:'SQUARE', count:5}] } },
            { type: 'OUTPUT', x: 700, y: 200, props: { acceptShape: 'SQUARE', targetCount: 5 } }
        ]
    },
    {
        id: 2, title: "í˜•ìƒ ì¸ì‹ í”„ë¡œí† ì½œ", grant: 100, power: 55, reward: 12,
        desc: "<strong>ëª©í‘œ:</strong> íŒŒë€ìƒ‰ ë„¤ëª¨ 10ê°œ ìˆ˜ì§‘.<br>ì´ë²ˆì—” ìƒ‰ìƒì´ ëª¨ë‘ íŒŒë€ìƒ‰ì´ì§€ë§Œ ëª¨ì–‘ì´ ë‹¤ë¦…ë‹ˆë‹¤.<br><strong>Shape Sorter</strong>ë¥¼ ì‚¬ìš©í•˜ì—¬ ë„¤ëª¨ë§Œ ê³¨ë¼ë‚´ì„¸ìš”.",
        preset: [
            { type: 'SOURCE', x: 100, y: 300, props: { spawnList: [{color:'BLUE', shape:'CIRCLE', count:10}, {color:'BLUE', shape:'SQUARE', count:10}] } },
            { type: 'OUTPUT', x: 700, y: 300, props: { acceptShape: 'SQUARE', targetCount: 10 } }
        ]
    },
    {
        id: 3, title: "ë¶€í•˜ ë¶„ì‚° ì²˜ë¦¬", grant: 150, power: 60, reward: 15,
        desc: "<strong>ëª©í‘œ:</strong> ë‘ ì„œë²„ì— ë°ì´í„° 10ê°œì”© ë¶„ë°°.<br>ë‹¨ì¼ ë¼ì¸ìœ¼ë¡œëŠ” ì²˜ë¦¬ëŸ‰ì´ ë¶€ì¡±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.<br><strong>Balancer</strong>ë¡œ íŠ¸ë˜í”½ì„ ì •í™•íˆ 50:50ìœ¼ë¡œ ë‚˜ëˆ„ì„¸ìš”.",
        preset: [
            { type: 'SOURCE', x: 100, y: 300, props: { spawnList: [{color:'RED', shape:'CIRCLE', count:20}] } },
            { type: 'OUTPUT', x: 700, y: 200, props: { acceptColor: 'RED', targetCount: 10 } },
            { type: 'OUTPUT', x: 700, y: 400, props: { acceptColor: 'RED', targetCount: 10 } }
        ]
    },
    {
        id: 4, title: "ì˜¤ì—¼ëœ ë°ì´í„°", grant: 0, power: 70, reward: 18,
        desc: "<strong>ëª©í‘œ:</strong> ì´ˆë¡ìƒ‰ ì‚¼ê°í˜• 10ê°œ ìˆ˜ì§‘.<br>ë°ì´í„°ì— 'ë…¸ì´ì¦ˆ(Noise)'ê°€ ì„ì—¬ ìˆìŠµë‹ˆë‹¤.<br>í•„ìš” ì—†ëŠ” ë°ì´í„°ëŠ” ë°˜ë“œì‹œ <strong>Trash</strong>ë¡œ ë³´ë‚´ ì œê±°í•´ì•¼ ì‹œìŠ¤í…œì´ ë§‰íˆì§€ ì•ŠìŠµë‹ˆë‹¤.",
        preset: [
            { type: 'SOURCE', x: 100, y: 300, props: { spawnList: [{color:'GREEN', shape:'TRIANGLE', count:10}, {color:'RED', shape:'SQUARE', count:10}, {color:'BLUE', shape:'CIRCLE', count:5}] } },
            { type: 'OUTPUT', x: 700, y: 250, props: { acceptColor: 'GREEN', targetCount: 10 } }
        ]
    },
    {
        id: 5, title: "ë¨¸ì‹ ëŸ¬ë‹ì˜ ì‹œì‘", grant: 200, power: 80, reward: 20,
        desc: "<strong>ëª©í‘œ:</strong> íŒŒë€ìƒ‰ ë°ì´í„° ë¶„ë¥˜ (AI í™œìš©).<br>ë³µì¡í•œ íŒ¨í„´ì´ ê°ì§€ë©ë‹ˆë‹¤. <strong>Perceptron AI</strong>ë¥¼ ì‚¬ìš©í•´ë³´ì„¸ìš”.<br>ì²˜ìŒì—” ì‹¤ìˆ˜í•˜ì§€ë§Œ ë°ì´í„°ë¥¼ ì²˜ë¦¬í• ìˆ˜ë¡ ì •í™•ë„ê°€ 100%ì— ë„ë‹¬í•©ë‹ˆë‹¤.",
        preset: [
            { type: 'SOURCE', x: 100, y: 300, props: { spawnList: [{color:'BLUE', shape:'CIRCLE', count:15}, {color:'RED', shape:'TRIANGLE', count:15}] } },
            { type: 'OUTPUT', x: 750, y: 300, props: { acceptColor: 'BLUE', targetCount: 15 } }
        ]
    },
    {
        id: 6, title: "ë©€í‹° ìŠ¤íŠ¸ë¦¼ ë³‘í•©", grant: 0, power: 90, reward: 25,
        desc: "<strong>ëª©í‘œ:</strong> ë¹¨ê°„ìƒ‰ì€ Aì„œë²„, íŒŒë€ìƒ‰ì€ Bì„œë²„ë¡œ.<br>ë‘ ê°œì˜ ì œë„ˆë ˆì´í„°ì—ì„œ ë°ì´í„°ê°€ ìŸì•„ì§‘ë‹ˆë‹¤.<br>ê° ë¼ì¸ì„ í•©ì¹˜ê±°ë‚˜ êµì°¨ì‹œì¼œ ì˜¬ë°”ë¥¸ ëª©ì ì§€ë¡œ ë³´ë‚´ì„¸ìš”.",
        preset: [
            { type: 'SOURCE', x: 80, y: 150, props: { spawnList: [{color:'RED', shape:'SQUARE', count:10}, {color:'BLUE', shape:'CIRCLE', count:5}] } },
            { type: 'SOURCE', x: 80, y: 450, props: { spawnList: [{color:'BLUE', shape:'CIRCLE', count:10}, {color:'RED', shape:'SQUARE', count:5}] } },
            { type: 'OUTPUT', x: 800, y: 150, props: { acceptColor: 'RED', targetCount: 15 } },
            { type: 'OUTPUT', x: 800, y: 450, props: { acceptColor: 'BLUE', targetCount: 15 } }
        ]
    },
    {
        id: 7, title: "ê³ ì† ì²˜ë¦¬ ì•„í‚¤í…ì²˜", grant: 300, power: 100, reward: 30,
        desc: "<strong>ëª©í‘œ:</strong> ëŒ€ëŸ‰ ë°ì´í„° ì²˜ë¦¬.<br>ë°ì´í„° ìœ ì… ì†ë„ê°€ ë§¤ìš° ë¹ ë¦…ë‹ˆë‹¤. ìˆ˜ìµì„ ì¬íˆ¬ìí•˜ì—¬<br>ìƒì ì—ì„œ <strong>CPU Overclocking</strong>ì„ ì—…ê·¸ë ˆì´ë“œí•´ì•¼ ì›í™œí•œ ì²˜ë¦¬ê°€ ê°€ëŠ¥í•©ë‹ˆë‹¤.",
        preset: [
            { type: 'SOURCE', x: 50, y: 300, props: { spawnList: [{color:'GREEN', shape:'SQUARE', count:40}] } },
            { type: 'OUTPUT', x: 800, y: 200, props: { acceptColor: 'GREEN', targetCount: 20 } },
            { type: 'OUTPUT', x: 800, y: 400, props: { acceptColor: 'GREEN', targetCount: 20 } }
        ]
    },
    {
        id: 8, title: "ë§ˆìŠ¤í„° ì•„í‚¤í…íŠ¸", grant: 0, power: 120, reward: 50,
        desc: "<strong>ìµœì¢… ëª©í‘œ:</strong> ëª¨ë“  ë°ì´í„° ì™„ë²½ ë¶„ë¥˜.<br>ëª¨ë“  ì¢…ë¥˜ì˜ ë°ì´í„°ê°€ ì„ì—¬ ë‚˜ì˜µë‹ˆë‹¤.<br>ì§€ê¸ˆê¹Œì§€ ë°°ìš´ ëª¨ë“  ê¸°ìˆ ì„ í™œìš©í•˜ì—¬ ì™„ë²½í•œ íŒŒì´í”„ë¼ì¸ì„ êµ¬ì¶•í•˜ì„¸ìš”.",
        preset: [
            { type: 'SOURCE', x: 50, y: 300, props: { spawnList: [
                {color:'RED', shape:'SQUARE', count:10}, 
                {color:'BLUE', shape:'CIRCLE', count:10}, 
                {color:'GREEN', shape:'TRIANGLE', count:10}
            ] } },
            { type: 'OUTPUT', x: 850, y: 100, props: { acceptShape: 'SQUARE', targetCount: 10 } },
            { type: 'OUTPUT', x: 850, y: 300, props: { acceptShape: 'CIRCLE', targetCount: 10 } },
            { type: 'OUTPUT', x: 850, y: 500, props: { acceptShape: 'TRIANGLE', targetCount: 10 } }
        ]
    }
];

class Packet {
    constructor(color, shape, start, end, outIdx, inIdx) {
        this.colorKey = color; this.color = COLORS[color]; this.shape = shape;
        this.start = start; this.end = end; this.outIdx = outIdx; this.inIdx = inIdx;
        this.t = 0;
        let baseSpeed = 0.015;
        if(shape === 'TRIANGLE') baseSpeed *= 1.5;
        if(shape === 'SQUARE') baseSpeed *= 0.8;
        this.baseSpeed = baseSpeed;
        this.arrived = false;
    }
    update(mult) {
        this.t += this.baseSpeed * mult;
        if(this.t >= 1) { this.t = 1; this.arrived = true; }
    }
    draw(ctx) {
        const sx = this.start.getOutPos(this.outIdx).x;
        const sy = this.start.getOutPos(this.outIdx).y;
        const ex = this.end.getInPos(this.inIdx).x;
        const ey = this.end.getInPos(this.inIdx).y;
        const dist = Math.abs(ex-sx); const cp1x = sx+dist*0.5; const cp2x = ex-dist*0.5;
        const t = this.t; const invT = 1-t;
        const x = Math.pow(invT,3)*sx + 3*Math.pow(invT,2)*t*cp1x + 3*invT*Math.pow(t,2)*cp2x + Math.pow(t,3)*ex;
        const y = Math.pow(invT,3)*sy + 3*Math.pow(invT,2)*t*sy + 3*invT*Math.pow(t,2)*ey + Math.pow(t,3)*ey;

        ctx.fillStyle = this.color; ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
        if(game.speedMultiplier > 1.2) {
            ctx.globalAlpha = 0.3; ctx.beginPath(); ctx.arc(x-(x-sx)*0.05, y-(y-sy)*0.05, 5, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1.0;
        }
        ctx.beginPath();
        if(this.shape === 'SQUARE') ctx.rect(x-6, y-6, 12, 12);
        else if(this.shape === 'TRIANGLE') { ctx.moveTo(x, y-6); ctx.lineTo(x+6, y+6); ctx.lineTo(x-6, y+6); ctx.closePath(); }
        else ctx.arc(x, y, 6, 0, Math.PI*2);
        ctx.fill(); ctx.stroke();
    }
}

class Node {
    constructor(type, x, y) {
        this.type = type; this.x = x; this.y = y;
        this.w = 160; this.h = 80;
        this.inputs = []; this.outputs = [];
        this.props = {}; this.state = { accuracy: 0.5, trained: 0, toggle: 0 };
        this.queue = []; this.collectedCount = 0;
        
        const t = NODE_TYPES[type] || {name: "Unknown", color: "#333"};
        this.name = type === 'SOURCE' ? "Generator" : (type === 'OUTPUT' ? "Server" : t.name);
        this.color = type === 'SOURCE' ? "#444" : (type === 'OUTPUT' ? "#222" : "#333");
        if(type === 'PERCEPTRON') this.color = "#4a3b69";
        
        if(type === 'SOURCE') { this.outputs = [null]; this.props.spawnList = []; }
        else if(type === 'OUTPUT') { this.inputs = [0]; this.props.targetCount = 0; }
        else {
            this.inputs = [0]; 
            this.outputs = (type === 'TRASH') ? [] : [null, null];
            if(type === 'FILTER') this.props.filterColor = 'RED';
            if(type === 'SHAPE_SORTER') this.props.targetShape = 'SQUARE';
            if(type === 'PERCEPTRON') this.props.targetColor = 'BLUE';
        }
    }

    getInPos(idx) { return { x: this.x, y: this.y + (this.h/(this.inputs.length+1))*(idx+1) }; }
    getOutPos(idx) { return { x: this.x + this.w, y: this.y + (this.h/(this.outputs.length+1))*(idx+1) }; }

    receive(p) {
        if(this.type === 'OUTPUT') game.checkGoal(this, p);
        else if(this.type !== 'TRASH') this.process(p);
        else AudioSys.playTone('trash'); 
    }

    process(p) {
        let outPort = 0;
        if(['FILTER','SHAPE_SORTER','PERCEPTRON'].includes(this.type)) {
            game.spawnParticles(this.x + this.w/2, this.y + this.h/2, COLORS[p.colorKey], 3);
        }

        if(this.type === 'SOURCE') outPort = 0;
        else if(this.type === 'FILTER') outPort = (p.colorKey === this.props.filterColor) ? 0 : 1;
        else if(this.type === 'SHAPE_SORTER') outPort = (p.shape === this.props.targetShape) ? 0 : 1;
        else if(this.type === 'BALANCER') { outPort = this.state.toggle; this.state.toggle ^= 1; }
        else if(this.type === 'PERCEPTRON') {
            const isMatch = (p.colorKey === this.props.targetColor);
            const correct = isMatch ? 0 : 1;
            if(this.state.accuracy < 1.0) this.state.accuracy += 0.05;
            if(Math.random() < this.state.accuracy) outPort = correct;
            else { outPort = correct === 0 ? 1 : 0; game.addEffect(this.x+this.w/2, this.y, "ERROR", "#f00"); }
        }

        if(this.outputs[outPort]) {
            game.packets.push(new Packet(p.colorKey, p.shape, this, this.outputs[outPort].node, outPort, this.outputs[outPort].inIdx));
        }
    }

    draw(ctx) {
        ctx.fillStyle = this.color; ctx.strokeStyle = (game.selectedNode===this)?'#fff':'#555'; ctx.lineWidth=2;
        ctx.beginPath(); ctx.roundRect(this.x, this.y, this.w, this.h, 10); ctx.fill(); ctx.stroke();
        
        ctx.fillStyle = '#fff'; ctx.font = 'bold 13px Segoe UI'; ctx.textAlign = 'center';
        ctx.fillText(this.name, this.x + this.w/2, this.y + 20);

        const power = NODE_TYPES[this.type] ? NODE_TYPES[this.type].power : 0;
        if(power > 0) {
            ctx.fillStyle = 'var(--power)'; ctx.font = 'bold 11px Consolas';
            ctx.fillText(`âš¡${power}W`, this.x+this.w-25, this.y+15);
        }

        if(this.type === 'SOURCE' && this.props.spawnList) {
            const counts = {};
            const data = (game.isRunning && this.queue.length>0) ? this.queue : this.createQueue();
            data.forEach(p => { const k=`${p.color}-${p.shape}`; if(!counts[k]) counts[k]={c:p.color, s:p.shape, n:0}; counts[k].n++; });
            
            let idx = 0; const w = 35; const sx = this.x + this.w/2 - (Object.keys(counts).length*w)/2 + w/2;
            for(let k in counts) {
                drawIcon(ctx, sx+idx*w, this.y+45, 12, counts[k].s, COLORS[counts[k].c]);
                ctx.fillStyle='#fff'; ctx.font='11px Consolas'; ctx.fillText(`x${counts[k].n}`, sx+idx*w, this.y+60);
                idx++;
            }
        } else if(this.type === 'OUTPUT') {
            if(this.props.acceptColor) drawIcon(ctx, this.x+this.w/2, this.y+45, 16, 'CIRCLE', COLORS[this.props.acceptColor]);
            else if(this.props.acceptShape) drawIcon(ctx, this.x+this.w/2, this.y+45, 16, this.props.acceptShape, '#aaa');
            
            ctx.fillStyle = this.collectedCount >= this.props.targetCount ? '#50fa7b' : '#fff';
            ctx.font = 'bold 12px Segoe UI';
            ctx.fillText(`${this.collectedCount}/${this.props.targetCount}`, this.x+this.w/2, this.y+32);
        } else {
            ctx.fillStyle = '#aaa'; ctx.font = '10px Segoe UI';
            let info = "";
            if(this.type === 'FILTER') info = `Filter: ${this.props.filterColor}`;
            if(this.type === 'SHAPE_SORTER') info = `Sort: ${this.props.targetShape}`;
            if(this.type === 'PERCEPTRON') {
                const w=80, h=4; ctx.fillStyle='#222'; ctx.fillRect(this.x+(this.w-w)/2, this.y+45, w, h);
                ctx.fillStyle='#0f0'; ctx.fillRect(this.x+(this.w-w)/2, this.y+45, w*this.state.accuracy, h);
                info = `Acc: ${Math.floor(this.state.accuracy*100)}%`; ctx.fillStyle='#fff';
            }
            if(info) ctx.fillText(info, this.x+this.w/2, this.y+35);
        }

        const r=5;
        this.inputs.forEach((_,i)=>{ const p=this.getInPos(i); ctx.fillStyle='#999'; ctx.beginPath(); ctx.arc(p.x,p.y,r,0,Math.PI*2); ctx.fill(); });
        this.outputs.forEach((l,i)=>{ const p=this.getOutPos(i); ctx.fillStyle=l?'#fff':'#555'; ctx.beginPath(); ctx.arc(p.x,p.y,r,0,Math.PI*2); ctx.fill(); });
    }

    createQueue() {
        let q=[];
        if(this.props.spawnList) this.props.spawnList.forEach(i => { for(let k=0; k<i.count; k++) q.push({color:i.color, shape:i.shape}); });
        return q;
    }
}

function drawIcon(ctx, x, y, size, shape, color) {
    ctx.fillStyle = color; ctx.beginPath();
    if(shape==='SQUARE'||shape===1) ctx.rect(x-size/2, y-size/2, size, size);
    else if(shape==='TRIANGLE'||shape===2) { ctx.moveTo(x, y-size/2); ctx.lineTo(x+size/2, y+size/2); ctx.lineTo(x-size/2, y+size/2); }
    else ctx.arc(x, y, size/2, 0, Math.PI*2);
    ctx.fill();
}

/**
 * ğŸ® ë©”ì¸ ê²Œì„ ë¡œì§
 */
const game = {
    canvas: document.getElementById('gameCanvas'),
    ctx: null,
    nodes: [], packets: [], effects: [], particles: [],
    level: 0, isRunning: false,
    money: 0, levelStartMoney: 0, maxPower: 50, currentPower: 0, speedMultiplier: 1.0,
    collected: {}, mouse: {x:0, y:0}, wireStart: null,

    init() {
        this.ctx = this.canvas.getContext('2d');
        this.initToolbox();
        window.onresize = () => this.resize(); this.resize();
        this.setupInput();
        this.loadLevel(1);
        this.loop();
    },

    initToolbox() {
        const tb = document.getElementById('toolbox');
        for(let type in NODE_TYPES) {
            const data = NODE_TYPES[type];
            if(['SOURCE','OUTPUT'].includes(type)) continue;
            const div = document.createElement('div');
            div.className = 'node-item';
            div.innerHTML = `
                <span class="node-tag ${data.tag==='AI'?'tag-ai':'tag-basic'}">${data.tag}</span>
                <span class="node-name">${data.name}</span>
                <span class="node-desc">${data.desc}</span>
                <div class="node-meta">
                    <span style="color:var(--power)">âš¡${data.power}W</span>
                </div>`;
            div.onclick = () => this.addNode(type);
            tb.appendChild(div);
        }
    },

    resize() { this.canvas.width = this.canvas.parentElement.offsetWidth; this.canvas.height = this.canvas.parentElement.offsetHeight; },

    loadLevel(id) {
        this.level = id;
        const data = LEVELS.find(l => l.id === id);
        this.clearAll();
        
        document.getElementById('m-title').innerText = `Level ${id}: ${data.title}`;
        document.getElementById('m-desc').innerHTML = data.desc;
        document.getElementById('mission-modal').style.display = 'flex';

        if(id === 1) { this.money = 0; this.maxPower = 50; this.speedMultiplier = 1.0; }
        else if(data.power) this.maxPower = Math.max(this.maxPower, data.power);
        
        if(data.grant) this.money += data.grant;
        this.levelStartMoney = this.money;

        data.preset.forEach(p => {
            const n = new Node(p.type, p.x, p.y);
            if(p.props) Object.assign(n.props, p.props);
            this.nodes.push(n);
        });
        this.updateUI();
    },

    clearAll() {
        this.stopSim();
        this.nodes = []; this.packets = []; this.particles = []; this.effects = [];
    },

    retrySim() {
        this.stopSim();
        this.packets = []; this.particles = []; this.effects = [];
        this.money = this.levelStartMoney; 
        this.nodes.forEach(n => {
            n.collectedCount = 0;
            if(n.type === 'SOURCE') {
                n.queue = n.createQueue();
                for(let i=n.queue.length-1; i>0; i--) { const j=Math.floor(Math.random()*(i+1)); [n.queue[i], n.queue[j]] = [n.queue[j], n.queue[i]]; }
            }
        });
        this.updateUI();
        this.showToast("ì‹œë®¬ë ˆì´ì…˜ ì¬ì‹œì‘ (ìê¸ˆ ë³µêµ¬ë¨)");
    },

    resetLevel() { if(confirm("ì´ˆê¸°í™” í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) this.loadLevel(this.level); },

    toggleRun() {
        if(this.isRunning) this.stopSim();
        else {
            AudioSys.init();
            this.nodes.filter(n=>n.type==='SOURCE').forEach(n => {
                if(!n.queue || n.queue.length===0) {
                    n.queue = n.createQueue();
                    for(let i=n.queue.length-1; i>0; i--) { const j=Math.floor(Math.random()*(i+1)); [n.queue[i], n.queue[j]] = [n.queue[j], n.queue[i]]; }
                }
            });

            this.isRunning = true;
            document.getElementById('run-btn').innerText = "â¹ ì •ì§€";
            document.getElementById('run-btn').classList.add('btn-stop');
            
            this.genTimer = setInterval(() => {
                let active = false;
                this.nodes.filter(n=>n.type==='SOURCE').forEach(s => {
                    if(s.queue.length > 0) {
                        active = true;
                        const item = s.queue.shift();
                        s.process({colorKey:item.color, shape:item.shape});
                        AudioSys.playTone('spawn'); 
                    }
                });
                if(!active && this.packets.length === 0) {
                    clearInterval(this.genTimer);
                    setTimeout(() => this.checkResult(), 1500);
                }
            }, 800 / this.speedMultiplier);
        }
    },

    stopSim() {
        this.isRunning = false; clearInterval(this.genTimer);
        const btn = document.getElementById('run-btn');
        btn.innerText = "â–¶ ì‹¤í–‰"; btn.classList.remove('btn-stop');
    },

    checkResult() {
        if (!this.isRunning) return;
        let win = true;
        this.nodes.filter(n=>n.type==='OUTPUT').forEach(n => {
            if(n.collectedCount < n.props.targetCount) win = false;
        });
        if(!win) {
            AudioSys.playTone('fail');
            alert("âŒ ì‘ì „ ì‹¤íŒ¨: ëª©í‘œ ìˆ˜ëŸ‰ ë¯¸ë‹¬");
            this.stopSim();
        }
    },

    checkGoal(node, p) {
        let ok = true;
        if(node.props.acceptColor && node.props.acceptColor !== p.colorKey) ok = false;
        if(node.props.acceptShape && node.props.acceptShape !== p.shape) ok = false;

        if(ok) {
            node.collectedCount++;
            AudioSys.playTone('success'); 
            const reward = LEVELS.find(l=>l.id===this.level).reward;
            this.money += reward;
            this.addEffect(node.x, node.y-20, `+$${reward}`, "#ffd700");
            
            for(let i=0; i<5; i++) this.particles.push(new Particle(node.x+node.w/2, node.y+node.h/2, "#ffd700"));

            this.updateUI();
            
            const outputs = this.nodes.filter(n=>n.type==='OUTPUT');
            if(outputs.every(n => n.collectedCount >= n.props.targetCount)) {
                setTimeout(() => {
                    AudioSys.playTone('clear'); 
                    alert("ğŸ‰ LEVEL CLEAR!");
                    if(this.level < LEVELS.length) this.loadLevel(this.level+1);
                    else alert("ğŸ† ALL LEVELS COMPLETED!");
                }, 500);
            }
        } else {
            AudioSys.playTone('fail');
            this.addEffect(node.x, node.y-20, "FATAL ERROR", "#f00");
            this.spawnParticles(node.x + node.w/2, node.y + node.h/2, "#f00", 10);
            this.stopSim();
            setTimeout(() => { alert("âŒ ì‘ì „ ì‹¤íŒ¨: ì„œë²„ì— ì˜ëª»ëœ ë°ì´í„° ìœ ì…!"); }, 50);
        }
    },
    
    spawnParticles(x, y, color, count) {
        for(let i=0; i<count; i++) this.particles.push(new Particle(x, y, color));
    },

    addNode(type) {
        if(this.isRunning) return;
        AudioSys.init(); 
        const conf = NODE_TYPES[type];
        if(this.currentPower + conf.power > this.maxPower) { this.showToast("ì „ë ¥ ë¶€ì¡±!"); return; }
        
        this.nodes.push(new Node(type, 200, 200));
        AudioSys.playTone('click');
        this.updateUI();
    },

    sellNode(n) {
        if(n.type==='SOURCE' || n.type==='OUTPUT') return;
        this.nodes = this.nodes.filter(x => x !== n);
        this.nodes.forEach(x => x.outputs = x.outputs.map(l => (l && l.node===n) ? null : l));
        AudioSys.playTone('click');
        this.updateUI();
    },

    updateUI() {
        let totalW = 0; this.nodes.forEach(n => {
            if(NODE_TYPES[n.type]) totalW += NODE_TYPES[n.type].power;
        });
        this.currentPower = totalW;
        
        document.getElementById('funds-display').innerText = this.money;
        document.getElementById('power-current').innerText = this.currentPower;
        document.getElementById('power-max').innerText = this.maxPower;
        document.getElementById('cpu-display').innerText = `${this.speedMultiplier.toFixed(1)} GHz`;
        
        const pct = Math.min(100, (this.currentPower/this.maxPower)*100);
        document.getElementById('power-bar').style.width = pct+'%';
        document.getElementById('power-bar').style.background = pct>90?'#f44': 'linear-gradient(90deg, var(--power), #0077ff)';
        
        let cleared = this.nodes.filter(n=>n.type==='OUTPUT' && n.collectedCount >= n.props.targetCount).length;
        let total = this.nodes.filter(n=>n.type==='OUTPUT').length;
        document.getElementById('goal-status').innerText = `${cleared}/${total} Servers Ready`;
    },

    openStore() { document.getElementById('store-modal').style.display='block'; this.updateStoreBtn(); },
    closeStore() { document.getElementById('store-modal').style.display='none'; },
    updateStoreBtn() {
        document.getElementById('btn-up-power').disabled = this.money < UPGRADE_COSTS.POWER;
        document.getElementById('btn-up-speed').disabled = this.money < UPGRADE_COSTS.SPEED;
    },
    buyUpgrade(type) {
        if(type==='POWER' && this.money >= UPGRADE_COSTS.POWER) {
            this.money -= UPGRADE_COSTS.POWER; this.maxPower += 30;
            this.addEffect(this.canvas.width/2, this.canvas.height/2, "MAX POWER UP!", "#00d2ff");
        } else if(type==='SPEED' && this.money >= UPGRADE_COSTS.SPEED) {
            this.money -= UPGRADE_COSTS.SPEED; this.speedMultiplier += 0.2;
            this.addEffect(this.canvas.width/2, this.canvas.height/2, "CPU BOOST!", "#ff9900");
        }
        AudioSys.playTone('success');
        this.updateUI(); this.updateStoreBtn();
    },
    
    addEffect(x, y, t, c) { this.effects.push({x,y,text:t,color:c,life:60}); },
    showToast(msg) {
        const t = document.getElementById('toast'); t.innerText=msg; t.style.opacity=1; t.style.top="90px";
        setTimeout(()=> { t.style.opacity=0; t.style.top="80px"; }, 1500);
    },
    closeModal() { document.getElementById('mission-modal').style.display='none'; AudioSys.init(); },

    loop() {
        this.update(); this.draw(); requestAnimationFrame(() => this.loop());
    },
    update() {
        if(this.isRunning) {
            this.packets.forEach(p => p.update(this.speedMultiplier));
            this.packets.filter(p=>p.arrived).forEach(p => p.end.receive(p));
            this.packets = this.packets.filter(p=>!p.arrived);
        }
        this.effects.forEach(e => {e.y-=0.5; e.life--;}); this.effects = this.effects.filter(e=>e.life>0);
        this.particles.forEach(p => {p.x+=p.vx; p.y+=p.vy; p.life--; p.size*=0.95;}); this.particles = this.particles.filter(p=>p.life>0);
    },
    draw() {
        const ctx = this.ctx;
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        this.nodes.forEach(n => {
            n.outputs.forEach((l,i) => {
                if(l) {
                    const s = n.getOutPos(i); const e = l.node.getInPos(l.inIdx);
                    ctx.beginPath(); ctx.moveTo(s.x, s.y);
                    const cp1x = s.x + Math.abs(e.x-s.x)*0.5;
                    ctx.bezierCurveTo(cp1x, s.y, cp1x, e.y, e.x, e.y);
                    ctx.strokeStyle='#555'; ctx.lineWidth=3; ctx.stroke();
                }
            });
        });
        if(this.wireStart) {
            const s=this.wireStart.node.getOutPos(this.wireStart.idx);
            ctx.beginPath(); ctx.moveTo(s.x,s.y); ctx.lineTo(this.mouse.x,this.mouse.y);
            ctx.strokeStyle='#fff'; ctx.setLineDash([5,5]); ctx.stroke(); ctx.setLineDash([]);
        }

        this.nodes.forEach(n => n.draw(ctx));
        this.packets.forEach(p => p.draw(ctx));
        
        this.particles.forEach(p => {
            ctx.globalAlpha = p.life/p.maxLife; ctx.fillStyle=p.color; 
            ctx.beginPath(); ctx.arc(p.x,p.y,p.size,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1.0;
        });
        
        this.effects.forEach(e => {
            ctx.globalAlpha = e.life/60; ctx.fillStyle=e.color; ctx.font='bold 14px Consolas';
            ctx.fillText(e.text, e.x, e.y); ctx.globalAlpha=1.0;
        });
    },

    setupInput() {
        const cvs = this.canvas;
        let dragNode = null;

        cvs.addEventListener('mousedown', e => {
            if(e.button !== 0) return;
            if(this.isRunning) return;
            const mx=e.offsetX, my=e.offsetY;
            AudioSys.init(); 

            for(let n of this.nodes) {
                for(let i=0; i<n.outputs.length; i++) {
                    const p = n.getOutPos(i);
                    if(Math.hypot(p.x-mx, p.y-my) < 12) {
                        this.wireStart = { node:n, idx:i }; return;
                    }
                }
            }
            for(let i=this.nodes.length-1; i>=0; i--) {
                const n = this.nodes[i];
                if(mx >= n.x && mx <= n.x+n.w && my >= n.y && my <= n.y+n.h) {
                    dragNode = n; return;
                }
            }
        });

        cvs.addEventListener('mousemove', e => {
            this.mouse.x = e.offsetX; this.mouse.y = e.offsetY;
            if(dragNode) { dragNode.x = e.offsetX - dragNode.w/2; dragNode.y = e.offsetY - dragNode.h/2; }
        });

        cvs.addEventListener('mouseup', e => {
            if(this.wireStart) {
                const mx=e.offsetX, my=e.offsetY;
                for(let n of this.nodes) {
                    for(let i=0; i<n.inputs.length; i++) {
                        const p = n.getInPos(i);
                        if(Math.hypot(p.x-mx, p.y-my) < 15) {
                            if(n !== this.wireStart.node) {
                                this.wireStart.node.outputs[this.wireStart.idx] = { node:n, inIdx:i };
                                AudioSys.playTone('click');
                            }
                        }
                    }
                }
                this.wireStart = null;
            }
            dragNode = null;
        });

        cvs.addEventListener('contextmenu', e => {
            e.preventDefault();
            if(this.isRunning) return;
            const mx=e.offsetX, my=e.offsetY;
            for(let i=this.nodes.length-1; i>=0; i--) {
                const n = this.nodes[i];
                if(mx >= n.x && mx <= n.x+n.w && my >= n.y && my <= n.y+n.h) {
                    this.sellNode(n); return;
                }
            }
        });
    }
};

class Particle {
    constructor(x, y, color) {
        this.x=x; this.y=y; this.color=color;
        const a = Math.random()*Math.PI*2; const s = Math.random()*2+1;
        this.vx=Math.cos(a)*s; this.vy=Math.sin(a)*s;
        this.life=30+Math.random()*20; this.maxLife=this.life; this.size=Math.random()*3+2;
    }
}

game.init();
</script>
</body>
</html>
