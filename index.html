<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Logic Node v17.3: Perfect Timing</title>
    <style>
        :root {
            --bg: #1e1e1e;
            --panel: #252526;
            --accent: #007acc;
            --text: #cccccc;
            --red: #ff5555;
            --blue: #55aaff;
            --green: #50fa7b;
            --yellow: #f1fa8c;
            --purple: #bd93f9;
            --gold: #ffd700;
            --power: #00d2ff;
            --cpu: #ff9900;
        }
        body {
            margin: 0; background-color: var(--bg); color: var(--text);
            font-family: 'Segoe UI', monospace; overflow: hidden;
            display: flex; flex-direction: column; height: 100vh;
            user-select: none; -webkit-user-select: none;
            touch-action: none;
        }

        /* í—¤ë” ìŠ¤íƒ€ì¼ */
        header {
            height: 60px; background: var(--panel); border-bottom: 1px solid #333;
            display: flex; align-items: center; padding: 0 20px;
            justify-content: space-between; box-shadow: 0 4px 10px rgba(0,0,0,0.3); z-index: 10;
            flex-shrink: 0;
        }
        .header-title { font-size: 1.3rem; font-weight: 800; color: white; letter-spacing: 1px; }
        .header-info { display: flex; gap: 10px; align-items: center; }
        
        .stat-item {
            font-family: 'Consolas', monospace; font-size: 0.95rem; 
            color: #ccc; background: rgba(0,0,0,0.3); padding: 8px 12px; 
            border-radius: 6px; border: 1px solid #444; display: flex; align-items: center;
            white-space: nowrap;
        }
        .stat-label { color: #888; margin-right: 6px; font-size: 0.85em; font-weight: bold; }

        .power-meter-box { width: 80px; height: 8px; background: #111; border-radius: 4px; overflow: hidden; margin-left: 6px; }
        .power-fill { height: 100%; background: linear-gradient(90deg, var(--power), #0077ff); width: 0%; transition: width 0.3s; }
        
        #funds-display { color: var(--gold); font-weight: bold; font-size: 1.1em; }
        #cpu-display { color: var(--cpu); font-weight: bold; font-size: 1.1em; text-shadow: 0 0 5px rgba(255, 153, 0, 0.3); }
        #time-display { color: #ff5555; font-weight: bold; font-size: 1.1em; }

        /* ë©”ì¸ ë ˆì´ì•„ì›ƒ */
        #main { display: flex; flex: 1; position: relative; overflow: hidden; }

        /* íˆ´ë°•ìŠ¤ */
        #toolbox {
            width: 260px; background: #2d2d30; border-right: 1px solid #333;
            padding: 15px; display: flex; flex-direction: column; gap: 12px;
            z-index: 5; overflow-y: auto; height: 100%; box-sizing: border-box;
            flex-shrink: 0;
        }
        .node-item {
            background: #3e3e42; padding: 12px; border-radius: 8px;
            cursor: pointer; border: 1px solid #555; transition: all 0.2s ease;
            position: relative; box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .node-item:hover { background: #505050; border-color: var(--power); transform: translateX(5px); }
        .node-name { font-weight: bold; color: #fff; font-size: 0.95rem; }
        .node-desc { display: block; color: #bbb; font-size: 0.75em; margin-top: 4px; }
        .node-meta { display: flex; justify-content: flex-end; margin-top: 8px; font-size: 0.9em; font-weight: bold; }
        .node-tag { position: absolute; top: 10px; right: 10px; font-size: 0.65em; padding: 2px 6px; border-radius: 4px; background: #555; color: #fff; }
        .tag-ai { background: var(--purple); color: #222; }

        /* ìº”ë²„ìŠ¤ */
        #canvas-container { flex: 1; position: relative; background-color: #222; overflow: hidden; }
        canvas { display: block; width: 100%; height: 100%; cursor: crosshair; touch-action: none; }

        /* íˆ´íŒ */
        #tooltip {
            position: absolute; display: none; pointer-events: none;
            background: rgba(0, 0, 0, 0.9); border: 1px solid #777;
            padding: 8px 12px; border-radius: 4px; color: #fff;
            font-size: 0.85rem; z-index: 1000; white-space: pre-line;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            font-family: 'Consolas', monospace;
        }

        /* ì»¨íŠ¸ë¡¤ */
        #controls { position: absolute; bottom: 30px; right: 30px; display: flex; gap: 10px; z-index: 20;}
        .action-btn {
            background: var(--accent); color: white; border: none; padding: 12px 24px;
            font-size: 1rem; cursor: pointer; border-radius: 6px; font-weight: bold;
            transition: 0.2s; box-shadow: 0 4px 6px rgba(0,0,0,0.3); white-space: nowrap;
        }
        .action-btn:active { transform: translateY(2px); filter: brightness(0.9); }
        .btn-stop { background: var(--red); }
        .btn-retry { background: #4caf50; }
        .btn-clear { background: #444; }
        .btn-store { background: var(--gold); color: #222; }

        #toast {
            position: absolute; top: 80px; left: 50%; transform: translateX(-50%);
            background: rgba(255, 68, 68, 0.9); color: white; padding: 10px 20px;
            border-radius: 20px; font-weight: bold; opacity: 0; pointer-events: none; transition: opacity 0.3s; z-index: 100;
            width: max-content;
        }

        /* ëª¨ë‹¬ */
        .modal-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); display: flex; justify-content: center; align-items: center;
            z-index: 100; backdrop-filter: blur(5px); display: none;
        }
        .modal-content {
            background: #252526; border: 1px solid #555; padding: 40px;
            border-radius: 12px; max-width: 500px; width: 90%; text-align: center;
            box-shadow: 0 20px 50px rgba(0,0,0,0.8);
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes popIn { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }

        .modal-title { font-size: 2rem; margin: 0 0 20px 0; color: white; }
        .modal-text { font-size: 1.1rem; line-height: 1.6; color: #ddd; margin-bottom: 30px; text-align: left; }
        
        .result-win { border-color: var(--green); }
        .result-win .modal-title { color: var(--green); }
        .result-fail { border-color: var(--red); }
        .result-fail .modal-title { color: var(--red); }

        #store-modal .modal-content { border: 2px solid var(--gold); width: 450px; }
        .upgrade-item {
            display: flex; justify-content: space-between; align-items: center;
            background: #333; padding: 15px; margin-bottom: 10px; border-radius: 8px; border: 1px solid #444; text-align: left;
        }
        .up-btn { background: var(--gold); color: #222; border: none; padding: 8px 12px; border-radius: 4px; font-weight: bold; cursor: pointer; }
        .up-btn:disabled { background: #555; color: #888; cursor: not-allowed; }
        .close-btn { position: absolute; top: 15px; right: 15px; color: #aaa; cursor: pointer; font-size: 1.5rem; }

        @media (max-width: 768px) {
            header { padding: 0 10px; height: 50px; }
            .header-title { font-size: 1rem; }
            .stat-item { padding: 4px 8px; font-size: 0.8rem; }
            .stat-label { margin-right: 4px; }
            .power-meter-box { width: 40px; }
            .header-info { gap: 5px; }
            #goal-status { font-size: 0.8rem; }
            #main { flex-direction: column; }
            #canvas-container { width: 100%; flex: 1; }
            #toolbox {
                width: 100%; height: 140px; border-right: none; border-top: 1px solid #333;
                flex-direction: row; overflow-x: auto; overflow-y: hidden; padding: 10px; gap: 10px; background: #222;
            }
            .node-item { min-width: 140px; height: 100px; box-sizing: border-box; display: flex; flex-direction: column; justify-content: center; }
            #controls { bottom: 10px; right: 10px; flex-wrap: wrap; justify-content: flex-end; max-width: 300px; }
            .action-btn { padding: 8px 16px; font-size: 0.9rem; }
            .modal-content { width: 85%; padding: 20px; }
            .modal-title { font-size: 1.5rem; }
            .modal-text { font-size: 0.95rem; }
        }
    </style>
</head>
<body>

<header>
    <div class="header-title">LOGIC NODE</div>
    <div class="header-info">
        <div class="stat-item" style="border-color: var(--gold);">
            <span class="stat-label">MON</span>$<span id="funds-display">0</span>
        </div>
        <div class="stat-item" style="border-color: var(--cpu);">
            <span class="stat-label">CPU</span><span id="cpu-display">1.0G</span>
        </div>
        <div class="stat-item" style="border-color: var(--red);">
            <span class="stat-label">TIME</span><span id="time-display">60s</span>
        </div>
        <div class="stat-item" style="border-color: var(--power);">
            <span class="stat-label">PWR</span>
            <div class="power-meter-box"><div class="power-fill" id="power-bar"></div></div>
            <span style="font-size:0.8em; margin-left:4px; font-weight:bold; color:var(--power)">
                <span id="power-current">0</span>/<span id="power-max">50</span>
            </span>
        </div>
        <div class="stat-item">
            <span class="stat-label">GOAL</span><span id="goal-status" style="color:white; font-weight:bold; font-size:0.8rem;">...</span>
        </div>
    </div>
</header>

<div id="toast">ì•Œë¦¼</div>
<div id="tooltip">Tooltip</div>

<!-- ìƒì  ëª¨ë‹¬ -->
<div id="store-modal" class="modal-overlay">
    <div class="modal-content">
        <span class="close-btn" onclick="game.closeStore()">âœ•</span>
        <h2 style="color:var(--gold); margin-top:0;">ğŸ› ï¸ Store</h2>
        <div class="upgrade-item">
            <div><h4 style="margin:0; color:white">Power Supply</h4><p style="margin:0; font-size:0.8em; color:#aaa">+30 Max Power</p></div>
            <button class="up-btn" id="btn-up-power" onclick="game.buyUpgrade('POWER')">$200</button>
        </div>
        <div class="upgrade-item">
            <div><h4 style="margin:0; color:white">Overclocking</h4><p style="margin:0; font-size:0.8em; color:#aaa">+0.2 GHz Speed</p></div>
            <button class="up-btn" id="btn-up-speed" onclick="game.buyUpgrade('SPEED')">$300</button>
        </div>
    </div>
</div>

<!-- ê²°ê³¼ ëª¨ë‹¬ -->
<div id="result-modal" class="modal-overlay">
    <div class="modal-content" id="result-content">
        <h2 class="modal-title" id="result-title">LEVEL CLEAR!</h2>
        <p class="modal-text" id="result-desc">Success!</p>
        <div style="display:flex; justify-content:center; gap:10px;">
            <button class="action-btn btn-retry" onclick="game.retrySim(); game.closeResult();">â†º Retry</button>
            <button class="action-btn" id="btn-next-level" onclick="game.nextLevel()">Next â”</button>
        </div>
    </div>
</div>

<!-- ë¯¸ì…˜ ë¸Œë¦¬í•‘ -->
<div id="mission-modal" class="modal-overlay" style="display:flex;">
    <div class="modal-content">
        <h2 class="modal-title" id="m-title">Level 1</h2>
        <div class="modal-text" id="m-desc">Loading...</div>
        <button class="action-btn" onclick="game.closeModal()">Start</button>
    </div>
</div>

<div id="main">
    <div id="canvas-container">
        <canvas id="gameCanvas"></canvas>
        <div id="controls">
            <button class="action-btn btn-store" onclick="game.openStore()">ğŸ›’ ìƒì </button>
            <button class="action-btn btn-clear" onclick="game.resetLevel()">ğŸ—‘ï¸ ì´ˆê¸°í™”</button>
            <button class="action-btn btn-retry" onclick="game.retrySim()">â†º ì¬ì‹œë„</button>
            <button class="action-btn" onclick="game.toggleRun()" id="run-btn">â–¶ ì‹¤í–‰</button>
        </div>
    </div>
    <div id="toolbox">
        <!-- JS ìƒì„± -->
    </div>
</div>

<script>
const AudioSys = {
    ctx: null, noiseBuffer: null,
    init() { 
        if (!this.ctx) { 
            this.ctx = new (window.AudioContext || window.webkitAudioContext)(); 
            const bufferSize = this.ctx.sampleRate * 0.5; 
            const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            this.noiseBuffer = buffer;
        } 
        if (this.ctx.state === 'suspended') this.ctx.resume(); 
    },
    playTone(type) {
        if (!this.ctx) return;
        const now = this.ctx.currentTime;
        if (type === 'trash') { 
            if (this.noiseBuffer) {
                const src = this.ctx.createBufferSource(); src.buffer = this.noiseBuffer;
                src.playbackRate.value = 0.8 + Math.random() * 0.4;
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'bandpass'; filter.frequency.value = 1000 + Math.random() * 500; filter.Q.value = 0.5;
                gain.gain.setValueAtTime(0, now); gain.gain.linearRampToValueAtTime(1.5, now + 0.02); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
                src.connect(filter); filter.connect(gain); gain.connect(this.ctx.destination);
                src.start(now); src.stop(now + 0.3);
            }
        } else if (type === 'spawn') {
            const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
            osc.connect(gain); gain.connect(this.ctx.destination);
            osc.type = 'sine'; osc.frequency.setValueAtTime(600, now); osc.frequency.exponentialRampToValueAtTime(300, now + 0.1);
            gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
            osc.start(now); osc.stop(now + 0.1);
        } else if (type === 'success') {
            const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
            osc.connect(gain); gain.connect(this.ctx.destination);
            osc.type = 'square'; osc.frequency.setValueAtTime(1200, now); osc.frequency.setValueAtTime(1600, now + 0.1);
            gain.gain.setValueAtTime(0.05, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
            osc.start(now); osc.stop(now + 0.3);
        } else if (type === 'fail') {
            const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
            osc.connect(gain); gain.connect(this.ctx.destination);
            osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, now); osc.frequency.linearRampToValueAtTime(50, now + 0.5);
            gain.gain.setValueAtTime(0.2, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
            osc.start(now); osc.stop(now + 0.5);
        } else if (type === 'click') {
            const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
            osc.connect(gain); gain.connect(this.ctx.destination);
            osc.type = 'triangle'; osc.frequency.setValueAtTime(800, now);
            gain.gain.setValueAtTime(0.05, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
            osc.start(now); osc.stop(now + 0.05);
        } else if (type === 'clear') {
            this.playNote(523.25, now, 0.1); this.playNote(659.25, now+0.1, 0.1); this.playNote(783.99, now+0.2, 0.2); this.playNote(1046.50, now+0.3, 0.4);
        }
    },
    playNote(freq, time, dur) {
        const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
        osc.connect(gain); gain.connect(this.ctx.destination);
        osc.frequency.value = freq; gain.gain.setValueAtTime(0.1, time); gain.gain.exponentialRampToValueAtTime(0.01, time+dur);
        osc.start(time); osc.stop(time+dur);
    }
};

const COLORS = { RED:'#ff5555', BLUE:'#55aaff', GREEN:'#50fa7b', YELLOW:'#f1fa8c' };
const SHAPES = { CIRCLE:0, SQUARE:1, TRIANGLE:2 };
// âš¡ Node processing intervals (in ms) - tuned for better flow
const NODE_TYPES = {
    FILTER: { name: "Color Filter", desc: "ìƒ‰ìƒ ë¶„ë¥˜", power: 5, tag: "Basic", interval: 250 },
    SHAPE_SORTER: { name: "Shape Sorter", desc: "ëª¨ì–‘ ë¶„ë¥˜", power: 8, tag: "Shape", interval: 300 },
    PERCEPTRON: { name: "Perceptron AI", desc: "í•™ìŠµí˜• ë¶„ë¥˜ê¸°", power: 15, tag: "AI", interval: 400 },
    BALANCER: { name: "Balancer", desc: "ë¶€í•˜ ë¶„ì‚°", power: 3, tag: "Util", interval: 100 },
    TRASH: { name: "Trash", desc: "ë°ì´í„° ì‚­ì œ", power: 1, tag: "Util", interval: 50 }
};
const UPGRADE_COSTS = { POWER: 200, SPEED: 300 };

const LEVELS = [
    { id: 1, title: "ë°ì´í„° ì •ì œì˜ ê¸°ì´ˆ", grant: 0, power: 50, reward: 10, timeLimit: 60, desc: "<strong>ëª©í‘œ:</strong> ë„¤ëª¨(Square) 5ê°œ ìˆ˜ì§‘.<br>ì œë„ˆë ˆì´í„° í¬íŠ¸ê°€ í•˜ë‚˜ë¡œ í†µí•©ë˜ì—ˆìŠµë‹ˆë‹¤. ì—¬ëŸ¬ ë¼ì¸ì„ ì—°ê²°í•˜ë©´ ë” ë¹ ë¥´ê²Œ ë‚´ë³´ë‚¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.<br>ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ë°ì´í„°ëŠ” ë°˜ë“œì‹œ <strong>Trash</strong>ì— ì—°ê²°í•˜ì„¸ìš”!", preset: [{ type: 'SOURCE', x: 100, y: 300, props: { spawnList: [{color:'RED', shape:'CIRCLE', count:5}, {color:'BLUE', shape:'SQUARE', count:5}] } }, { type: 'OUTPUT', x: 700, y: 200, props: { acceptShape: 'SQUARE', targetCount: 5 } }, { type: 'TRASH', x: 700, y: 400, props: {} }] },
    { id: 2, title: "í˜•ìƒ ì¸ì‹ í”„ë¡œí† ì½œ", grant: 100, power: 55, reward: 12, timeLimit: 50, desc: "<strong>ëª©í‘œ:</strong> íŒŒë€ìƒ‰ ë„¤ëª¨ 10ê°œ ìˆ˜ì§‘.<br><strong>Shape Sorter</strong>ë¥¼ ì‚¬ìš©í•˜ì—¬ ë„¤ëª¨ë§Œ ê³¨ë¼ë‚´ì„¸ìš”.", preset: [{ type: 'SOURCE', x: 100, y: 300, props: { spawnList: [{color:'BLUE', shape:'CIRCLE', count:10}, {color:'BLUE', shape:'SQUARE', count:10}] } }, { type: 'OUTPUT', x: 700, y: 300, props: { acceptShape: 'SQUARE', targetCount: 10 } }, { type: 'TRASH', x: 700, y: 450, props: {} }] },
    { id: 3, title: "ë¶€í•˜ ë¶„ì‚° ì²˜ë¦¬", grant: 150, power: 60, reward: 15, timeLimit: 45, desc: "<strong>ëª©í‘œ:</strong> ë‘ ì„œë²„ì— ë°ì´í„° 10ê°œì”© ë¶„ë°°.<br>ì…ë ¥ëŸ‰ì´ ë§ìœ¼ë©´ ëŒ€ê¸°ì—´ì´ ìƒê¹ë‹ˆë‹¤. <strong>Balancer</strong>ë¡œ ë¶€í•˜ë¥¼ ë‚˜ëˆ„ì„¸ìš”.", preset: [{ type: 'SOURCE', x: 100, y: 300, props: { spawnList: [{color:'RED', shape:'CIRCLE', count:20}] } }, { type: 'OUTPUT', x: 700, y: 200, props: { acceptColor: 'RED', targetCount: 10 } }, { type: 'OUTPUT', x: 700, y: 400, props: { acceptColor: 'RED', targetCount: 10 } }, { type: 'TRASH', x: 550, y: 450, props: {} }] },
    { id: 4, title: "ì˜¤ì—¼ëœ ë°ì´í„°", grant: 0, power: 70, reward: 18, timeLimit: 60, desc: "<strong>ëª©í‘œ:</strong> ì´ˆë¡ìƒ‰ ì‚¼ê°í˜• 10ê°œ ìˆ˜ì§‘.<br>ë…¸ì´ì¦ˆ ë°ì´í„°ë¥¼ ê±¸ëŸ¬ë‚´ì„¸ìš”.", preset: [{ type: 'SOURCE', x: 100, y: 300, props: { spawnList: [{color:'GREEN', shape:'TRIANGLE', count:10}, {color:'RED', shape:'SQUARE', count:10}, {color:'BLUE', shape:'CIRCLE', count:5}] } }, { type: 'OUTPUT', x: 700, y: 250, props: { acceptColor: 'GREEN', acceptShape: 'TRIANGLE', targetCount: 10 } }, { type: 'TRASH', x: 700, y: 400, props: {} }] },
    { id: 5, title: "ë¨¸ì‹ ëŸ¬ë‹ì˜ ì‹œì‘", grant: 200, power: 80, reward: 20, timeLimit: 70, desc: "<strong>ëª©í‘œ:</strong> íŒŒë€ìƒ‰ ë°ì´í„° ë¶„ë¥˜ (AI í™œìš©).<br>AI ë…¸ë“œë¥¼ í´ë¦­í•˜ì—¬ íƒ€ê²Ÿì„ ì„¤ì •í•˜ê³  í•™ìŠµì‹œí‚¤ì„¸ìš”.", preset: [{ type: 'SOURCE', x: 100, y: 300, props: { spawnList: [{color:'BLUE', shape:'CIRCLE', count:15}, {color:'RED', shape:'TRIANGLE', count:15}] } }, { type: 'OUTPUT', x: 750, y: 300, props: { acceptColor: 'BLUE', targetCount: 15 } }, { type: 'TRASH', x: 750, y: 450, props: {} }] },
    { id: 6, title: "ë©€í‹° ìŠ¤íŠ¸ë¦¼ ë³‘í•©", grant: 0, power: 90, reward: 25, timeLimit: 80, desc: "<strong>ëª©í‘œ:</strong> ë¹¨ê°„ ë„¤ëª¨ / íŒŒë€ ì› ë¶„ë¥˜.<br>ë‘ ê°œì˜ ì œë„ˆë ˆì´í„°ë¥¼ ë™ì‹œì— ì²˜ë¦¬í•´ì•¼ í•©ë‹ˆë‹¤.", preset: [{ type: 'SOURCE', x: 80, y: 150, props: { spawnList: [{color:'RED', shape:'SQUARE', count:10}, {color:'BLUE', shape:'CIRCLE', count:5}] } }, { type: 'SOURCE', x: 80, y: 450, props: { spawnList: [{color:'BLUE', shape:'CIRCLE', count:10}, {color:'RED', shape:'SQUARE', count:5}] } }, { type: 'OUTPUT', x: 800, y: 150, props: { acceptColor: 'RED', acceptShape: 'SQUARE', targetCount: 15 } }, { type: 'OUTPUT', x: 800, y: 450, props: { acceptColor: 'BLUE', acceptShape: 'CIRCLE', targetCount: 15 } }, { type: 'TRASH', x: 400, y: 300, props: {} }] },
    { id: 7, title: "ê³ ì† ì²˜ë¦¬ ì•„í‚¤í…ì²˜", grant: 300, power: 100, reward: 30, timeLimit: 40, desc: "<strong>ëª©í‘œ:</strong> 40ê°œ ë°ì´í„° ì´ˆê³ ì† ì²˜ë¦¬.<br><strong>ì‹œê°„ ì œí•œì´ ë§¤ìš° ì§§ìŠµë‹ˆë‹¤.</strong><br>ìˆ˜ìµìœ¼ë¡œ CPU Overclockingì„ ì—…ê·¸ë ˆì´ë“œí•˜ì„¸ìš”.", preset: [{ type: 'SOURCE', x: 50, y: 300, props: { spawnList: [{color:'GREEN', shape:'SQUARE', count:40}] } }, { type: 'OUTPUT', x: 800, y: 200, props: { acceptColor: 'GREEN', acceptShape: 'SQUARE', targetCount: 20 } }, { type: 'OUTPUT', x: 800, y: 400, props: { acceptColor: 'GREEN', acceptShape: 'SQUARE', targetCount: 20 } }, { type: 'TRASH', x: 800, y: 550, props: {} }] },
    { id: 8, title: "ë§ˆìŠ¤í„° ì•„í‚¤í…íŠ¸", grant: 0, power: 120, reward: 50, timeLimit: 90, desc: "<strong>ìµœì¢… ëª©í‘œ:</strong> ëª¨ë“  ë°ì´í„° ì™„ë²½ ë¶„ë¥˜.<br>ëª¨ë“  ê¸°ìˆ ì„ ë™ì›í•˜ì—¬ ë³µì¡í•œ ë°ì´í„°ë¥¼ ì²˜ë¦¬í•˜ì„¸ìš”.", preset: [{ type: 'SOURCE', x: 50, y: 300, props: { spawnList: [{color:'RED', shape:'SQUARE', count:10}, {color:'BLUE', shape:'CIRCLE', count:10}, {color:'GREEN', shape:'TRIANGLE', count:10}] } }, { type: 'OUTPUT', x: 850, y: 100, props: { acceptShape: 'SQUARE', targetCount: 10 } }, { type: 'OUTPUT', x: 850, y: 300, props: { acceptShape: 'CIRCLE', targetCount: 10 } }, { type: 'OUTPUT', x: 850, y: 500, props: { acceptShape: 'TRIANGLE', targetCount: 10 } }, { type: 'TRASH', x: 400, y: 400, props: {} }] }
];

function drawShapeIcon(ctx,x,y,size,shape,color) {
    ctx.fillStyle=color; ctx.beginPath();
    if(shape==='SQUARE'||shape===1) ctx.rect(x-size/2,y-size/2,size,size);
    else if(shape==='TRIANGLE'||shape===2) { ctx.moveTo(x,y-size/2); ctx.lineTo(x+size/2,y+size/2); ctx.lineTo(x-size/2,y+size/2); }
    else ctx.arc(x,y,size/2,0,Math.PI*2);
    ctx.fill();
}
function shuffleArray(a) { for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];} return a;}

class Packet {
    constructor(c,s,start,end,oidx,iidx) {
        this.colorKey=c; this.color=COLORS[c]; this.shape=s; this.start=start; this.end=end; this.outIdx=oidx; this.inIdx=iidx;
        this.t=0; this.baseSpeed = (s==='TRIANGLE'?0.0012:(s==='SQUARE'?0.0006:0.0008)); // speed per ms
        this.arrived=false;
    }
    update(dt, m) { 
        this.t += this.baseSpeed * m * dt; 
        if(this.t>=1) { this.t=1; this.arrived=true; } 
    }
    draw(ctx) {
        const s=this.start.getOutPos(this.outIdx); const e=this.end.getInPos(this.inIdx);
        const sx=s.x, sy=s.y, ex=e.x, ey=e.y;
        const cp1x = sx + Math.abs(ex-sx)*0.5;
        const t=this.t; const it=1-t;
        const x=Math.pow(it,3)*sx + 3*Math.pow(it,2)*t*cp1x + 3*it*Math.pow(t,2)*cp1x + Math.pow(t,3)*ex;
        const y=Math.pow(it,3)*sy + 3*Math.pow(it,2)*t*sy + 3*it*Math.pow(t,2)*ey + Math.pow(t,3)*ey;

        ctx.fillStyle=this.color; ctx.strokeStyle='#fff'; ctx.lineWidth=2;
        if(game.speedMultiplier>1.2) { ctx.globalAlpha=0.3; ctx.beginPath(); ctx.arc(x-(x-sx)*0.05, y-(y-sy)*0.05, 5, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha=1.0; }
        ctx.beginPath();
        if(this.shape==='SQUARE') ctx.rect(x-6,y-6,12,12);
        else if(this.shape==='TRIANGLE') { ctx.moveTo(x,y-6); ctx.lineTo(x+6,y+6); ctx.lineTo(x-6,y+6); ctx.closePath(); }
        else ctx.arc(x,y,6,0,Math.PI*2);
        ctx.fill(); ctx.stroke();
    }
}

class Node {
    constructor(t,x,y) {
        this.type=t; this.x=x; this.y=y; this.w=160; this.h=80;
        this.inputs=[]; this.outputs=[]; this.props={}; 
        this.state={accuracy:0.5, trained:0, toggle:0}; 
        this.queue=[]; this.collectedCount=0;
        
        this.inputBuffer = []; this.processTimer = 0;
        this.maxInterval = NODE_TYPES[t] ? NODE_TYPES[t].interval : 0;
        
        const info = NODE_TYPES[t]||{name:"Unknown"}; this.name=t==='SOURCE'?"Generator":(t==='OUTPUT'?"Server":info.name);
        this.color=t==='SOURCE'?"#444":(t==='OUTPUT'?"#222":(t==='PERCEPTRON'?"#4a3b69":"#333"));
        
        // Multi-Link: Generator has 1 output, Server/Trash 1 input, others 2 outputs
        if(t==='SOURCE') { this.outputs=[[]]; this.props.spawnList=[]; }
        else if(t==='OUTPUT' || t==='TRASH') { this.inputs=[0]; this.props.targetCount=0; }
        else {
            this.inputs=[0]; 
            this.outputs=t==='TRASH'?[]:[[],[]]; // Standard nodes outputs
            if(t==='FILTER') this.props.filterColor='RED'; if(t==='SHAPE_SORTER') this.props.targetShape='SQUARE'; if(t==='PERCEPTRON') this.props.targetColor='BLUE';
        }
    }
    
    toggleConfig() {
        const colorOrder = ['RED', 'BLUE', 'GREEN'];
        const shapeOrder = ['SQUARE', 'CIRCLE', 'TRIANGLE'];
        if (this.type === 'FILTER') {
            const idx = colorOrder.indexOf(this.props.filterColor);
            this.props.filterColor = colorOrder[(idx + 1) % colorOrder.length];
        } else if (this.type === 'PERCEPTRON') {
            const idx = colorOrder.indexOf(this.props.targetColor);
            this.props.targetColor = colorOrder[(idx + 1) % colorOrder.length];
        } else if (this.type === 'SHAPE_SORTER') {
            const idx = shapeOrder.indexOf(this.props.targetShape);
            this.props.targetShape = shapeOrder[(idx + 1) % shapeOrder.length];
        }
    }

    getInPos(i) { return {x:this.x, y:this.y+(this.h/(this.inputs.length+1))*(i+1)}; }
    getOutPos(i) { return {x:this.x+this.w, y:this.y+(this.h/(this.outputs.length+1))*(i+1)}; }
    
    receive(p) { 
        if(this.type==='OUTPUT') game.checkGoal(this,p); 
        else if(this.type==='TRASH') { AudioSys.playTone('trash'); }
        else {
            this.inputBuffer.push({colorKey: p.colorKey, shape: p.shape});
        }
    }
    
    send(pData, portIdx) {
        if (this.outputs[portIdx]) {
            game.packets.push(new Packet(pData.colorKey, pData.shape, this, this.outputs[portIdx].node, portIdx, this.outputs[portIdx].inIdx));
        }
    }

    tick(dt, speedMult) {
        if (this.type === 'SOURCE' || this.type === 'OUTPUT' || this.type === 'TRASH') return;

        if (this.processTimer > 0) {
            this.processTimer -= dt * speedMult;
        }

        if (this.processTimer <= 0 && this.inputBuffer.length > 0) {
            const item = this.inputBuffer.shift();
            this.process(item);
            this.processTimer = this.maxInterval;
        }
    }

    process(p) {
        let op=0;
        if(['FILTER','SHAPE_SORTER','PERCEPTRON'].includes(this.type)) game.spawnParticles(this.x+this.w/2, this.y+this.h/2, COLORS[p.colorKey], 3);
        
        if(this.type==='FILTER') op=(p.colorKey===this.props.filterColor)?0:1;
        else if(this.type==='SHAPE_SORTER') op=(p.shape===this.props.targetShape)?0:1;
        else if(this.type==='BALANCER') { op=this.state.toggle; this.state.toggle^=1; }
        else if(this.type==='PERCEPTRON') {
            const match=p.colorKey===this.props.targetColor; const corr=match?0:1;
            if(this.state.accuracy<1.0) this.state.accuracy+=0.05;
            op=(Math.random()<this.state.accuracy)?corr:(corr===0?1:0);
            if(op!==corr) game.addEffect(this.x+this.w/2, this.y, "ERROR", "#f00");
        }
        
        if(this.type!=='SOURCE') {
            const targetLinks = this.outputs[op];
            if(targetLinks && targetLinks.length > 0) {
                targetLinks.forEach(link => {
                    game.packets.push(new Packet(p.colorKey, p.shape, this, link.node, op, link.inIdx));
                });
            } else {
                game.triggerFail(this.x + this.w/2, this.y + this.h/2, "ë°ì´í„° ìœ ì‹¤!", "ë°ì´í„°ê°€ ê°ˆ ê³³ì´ ì—†ìŠµë‹ˆë‹¤.\nëª¨ë“  ì¶œë ¥ í¬íŠ¸ë¥¼ ì—°ê²°í•˜ê±°ë‚˜ Trashì— ë²„ë¦¬ì„¸ìš”.");
            }
        }
    }

    draw(ctx) {
        ctx.fillStyle=this.color; ctx.strokeStyle=(game.selectedNode===this)?'#fff':'#555'; ctx.lineWidth=2;
        ctx.beginPath(); ctx.roundRect(this.x, this.y, this.w, this.h, 10); ctx.fill(); ctx.stroke();
        ctx.fillStyle='#fff'; ctx.font='bold 13px Segoe UI'; ctx.textAlign='center'; ctx.fillText(this.name, this.x+this.w/2, this.y+20);
        
        const pwr = NODE_TYPES[this.type]?NODE_TYPES[this.type].power:0;
        if(pwr>0) { ctx.fillStyle='var(--power)'; ctx.font='bold 11px Consolas'; ctx.fillText(`âš¡${pwr}W`, this.x+this.w-25, this.y+15); }

        if(this.inputBuffer.length > 0) {
            ctx.fillStyle='#ffcc00'; ctx.font='bold 11px Consolas'; 
            ctx.fillText(`Waiting: ${this.inputBuffer.length}`, this.x+this.w/2, this.y - 10);
        }

        if(this.type==='SOURCE' && this.props.spawnList) {
            const counts={}; const data=(game.isRunning && this.queue.length>0)?this.queue:this.createQueue();
            data.forEach(p=>{ const k=`${p.colorKey}-${p.shape}`; if(!counts[k]) counts[k]={c:p.colorKey,s:p.shape,n:0}; counts[k].n++; });
            let idx=0; const w=35; const sx=this.x+this.w/2 - (Object.keys(counts).length*w)/2 + w/2;
            for(let k in counts) {
                drawShapeIcon(ctx, sx+idx*w, this.y+45, 12, counts[k].s, COLORS[counts[k].c]);
                ctx.fillStyle='#fff'; ctx.font='11px Consolas'; ctx.fillText(`x${counts[k].n}`, sx+idx*w, this.y+60); idx++;
            }
        } else if(this.type==='OUTPUT') {
            if(this.props.acceptColor) drawShapeIcon(ctx, this.x+this.w/2, this.y+45, 16, 'CIRCLE', COLORS[this.props.acceptColor]);
            else if(this.props.acceptShape) drawShapeIcon(ctx, this.x+this.w/2, this.y+45, 16, this.props.acceptShape, '#aaa');
            ctx.fillStyle=this.collectedCount>=this.props.targetCount?'#50fa7b':'#fff'; ctx.font='bold 12px Segoe UI';
            ctx.fillText(`${this.collectedCount}/${this.props.targetCount}`, this.x+this.w/2, this.y+32);
        } else {
            ctx.fillStyle='#aaa'; ctx.font='10px Segoe UI'; let info="";
            if(this.type==='FILTER') { info=`Pass:`; drawShapeIcon(ctx, this.x+this.w/2 + 20, this.y+35, 8, 'CIRCLE', COLORS[this.props.filterColor]); }
            if(this.type==='SHAPE_SORTER') { info=`Sort:`; drawShapeIcon(ctx, this.x+this.w/2 + 20, this.y+35, 8, this.props.targetShape, '#aaa'); }
            if(this.type==='PERCEPTRON') {
                const w=80, h=4; ctx.fillStyle='#222'; ctx.fillRect(this.x+(this.w-w)/2, this.y+45, w, h);
                ctx.fillStyle='#0f0'; ctx.fillRect(this.x+(this.w-w)/2, this.y+45, w*this.state.accuracy, h);
                info=`Learn:`; drawShapeIcon(ctx, this.x+this.w/2 + 25, this.y+35, 8, 'CIRCLE', COLORS[this.props.targetColor]);
            }
            if(info) ctx.fillText(info, this.x+this.w/2 - 10, this.y+38);
        }
        const r=5;
        this.inputs.forEach((_,i)=>{const p=this.getInPos(i); ctx.fillStyle='#999'; ctx.beginPath(); ctx.arc(p.x,p.y,r,0,Math.PI*2); ctx.fill();});
        this.outputs.forEach((portLinks,i)=>{
            const p=this.getOutPos(i); 
            ctx.fillStyle= (Array.isArray(portLinks) && portLinks.length>0) ? '#fff':'#555'; 
            ctx.beginPath(); ctx.arc(p.x,p.y,r,0,Math.PI*2); ctx.fill();
        });
    }
    createQueue() {
        let q=[]; 
        if(this.props.spawnList) {
            this.props.spawnList.forEach(i=>{
                for(let k=0;k<i.count;k++) q.push({colorKey:i.color, shape:i.shape});
            });
        }
        return q;
    }
}

class Particle {
    constructor(x, y, color) {
        this.x=x; this.y=y; this.color=color;
        const a = Math.random()*6.28; const s = Math.random()*2+1;
        this.vx=Math.cos(a)*s; this.vy=Math.sin(a)*s;
        this.life=30+Math.random()*20; this.max=this.life; this.size=Math.random()*3+2;
    }
}

const game = {
    canvas: document.getElementById('gameCanvas'), ctx: null,
    nodes: [], packets: [], effects: [], particles: [],
    level: 0, isRunning: false,
    money: 0, levelStartMoney: 0, maxPower: 50, currentPower: 0, speedMultiplier: 1.0,
    collected: {}, mouse: {x:0, y:0}, wireStart: null,
    camera: { x: 0, y: 0, zoom: 1 }, isPanning: false, panStart: { x: 0, y: 0 }, lastPinchDist: 0,
    timeLeft: 0, lastTime: 0, sourceTimer: 800,

    init() {
        this.ctx = this.canvas.getContext('2d');
        this.initToolbox();
        window.onresize = () => this.resize(); this.resize();
        this.setupInput();
        this.loadLevel(1);
        requestAnimationFrame(t => this.loop(t));
    },
    
    initToolbox() {
        const tb = document.getElementById('toolbox');
        for(let type in NODE_TYPES) {
            const data = NODE_TYPES[type]; if(['SOURCE','OUTPUT'].includes(type)) continue;
            const div = document.createElement('div'); div.className = 'node-item';
            div.innerHTML = `<span class="node-tag ${data.tag==='AI'?'tag-ai':'tag-basic'}">${data.tag}</span><span class="node-name">${data.name}</span><span class="node-desc">${data.desc}</span><div class="node-meta"><span style="color:var(--power)">âš¡${data.power}W</span><span style="color:#aaa;font-size:0.8em;margin-left:5px;">~${data.interval}ms</span></div>`;
            div.onclick = () => this.addNode(type); tb.appendChild(div);
        }
    },
    
    resize() { this.canvas.width = this.canvas.parentElement.offsetWidth; this.canvas.height = this.canvas.parentElement.offsetHeight; },

    loadLevel(id) {
        this.level = id; const data = LEVELS.find(l=>l.id===id);
        this.clearAll();
        document.getElementById('m-title').innerText = `Level ${id}: ${data.title}`;
        document.getElementById('m-desc').innerHTML = data.desc;
        document.getElementById('mission-modal').style.display = 'flex';
        
        if(id===1) { this.money=0; this.maxPower=50; this.speedMultiplier=1.0; }
        else if(data.power) this.maxPower = Math.max(this.maxPower, data.power);
        if(data.grant) this.money += data.grant;
        this.levelStartMoney = this.money;
        this.timeLeft = data.timeLimit || 60;
        
        this.camera = { x: 0, y: 0, zoom: 1 };

        data.preset.forEach(p => {
            const n = new Node(p.type, p.x, p.y); if(p.props) Object.assign(n.props, p.props);
            this.nodes.push(n);
        });
        this.fitCameraToNodes();
        this.updateUI();
    },
    
    fitCameraToNodes() {
        if (this.nodes.length === 0) return;
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        this.nodes.forEach(n => {
            minX = Math.min(minX, n.x); minY = Math.min(minY, n.y);
            maxX = Math.max(maxX, n.x + n.w); maxY = Math.max(maxY, n.y + n.h);
        });
        const worldW = maxX - minX; const worldH = maxY - minY;
        const screenW = this.canvas.width; const screenH = this.canvas.height;
        this.camera.x = (screenW / 2) - (minX + worldW / 2);
        this.camera.y = (screenH / 2) - (minY + worldH / 2);
    },

    clearAll() { this.stopSim(); this.nodes=[]; this.packets=[]; this.particles=[]; this.effects=[]; },
    retrySim() {
        this.stopSim(); this.packets=[]; this.particles=[]; this.effects=[];
        this.money = this.levelStartMoney;
        const data = LEVELS.find(l=>l.id===this.level);
        this.timeLeft = data.timeLimit || 60;
        this.nodes.forEach(n => {
            n.collectedCount=0; n.inputBuffer=[]; n.processTimer=0;
            if(n.type==='SOURCE') { n.queue=n.createQueue(); shuffleArray(n.queue); }
        });
        this.updateUI(); this.showToast("ì¬ì‹œì‘: ìê¸ˆ ë° ì‹œê°„ ë³µêµ¬ë¨");
    },
    resetLevel() { if(confirm("ì´ˆê¸°í™” í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) this.loadLevel(this.level); },
    
    toggleRun() {
        if(this.isRunning) this.stopSim();
        else {
            AudioSys.init();
            this.nodes.filter(n=>n.type==='SOURCE').forEach(n => { if(!n.queue || n.queue.length===0) { n.queue=n.createQueue(); shuffleArray(n.queue); } });
            this.isRunning=true;
            this.lastTime = performance.now(); 
            document.getElementById('run-btn').innerText="â¹ ì •ì§€"; document.getElementById('run-btn').classList.add('btn-stop');
            
            this.genTimer = setInterval(() => {
                let active=false;
                
                // Time Limit Logic
                this.timeLeft -= (0.8 / this.speedMultiplier) / 10; 
                if(this.timeLeft <= 0) { this.timeLeft=0; this.showResult(false, "Time Over!"); this.stopSim(); return; }
                document.getElementById('time-display').innerText = Math.ceil(this.timeLeft)+'s';

                this.nodes.forEach(n => n.tick(16, this.speedMultiplier)); 

                this.nodes.filter(n=>n.type==='SOURCE').forEach(s => {
                    const links = s.outputs[0];
                    links.forEach(link => {
                        if(s.queue.length > 0) { 
                            active=true; 
                            const item=s.queue.shift(); 
                            game.packets.push(new Packet(item.colorKey, item.shape, s, link.node, 0, link.inIdx));
                            AudioSys.playTone('spawn'); 
                        }
                    });
                });
                
                const hasPackets = this.packets.length > 0;
                const hasQueue = this.nodes.some(n => n.inputBuffer && n.inputBuffer.length > 0);
                const sourcesEmpty = this.nodes.filter(n=>n.type==='SOURCE').every(s=>s.queue.length===0);

                if(sourcesEmpty && !active && !hasPackets && !hasQueue) { clearInterval(this.genTimer); setTimeout(()=>this.checkResult(), 1500); }
            }, 800/this.speedMultiplier);
        }
    },
    stopSim() { this.isRunning=false; clearInterval(this.genTimer); document.getElementById('run-btn').innerText="â–¶ ì‹¤í–‰"; document.getElementById('run-btn').classList.remove('btn-stop'); },
    
    checkResult() {
        if(!this.isRunning) return;
        let win = true;
        this.nodes.filter(n=>n.type==='OUTPUT').forEach(n => { if(n.collectedCount < n.props.targetCount) win=false; });
        if(!win) { AudioSys.playTone('fail'); this.showResult(false); this.stopSim(); }
    },
    
    triggerFail(x, y, shortMsg, longMsg) {
        if(!this.isRunning) return;
        AudioSys.playTone('fail');
        this.addEffect(x, y, shortMsg || "ERROR", "#f00");
        this.spawnParticles(x, y, "#f00", 10);
        this.stopSim();
        setTimeout(() => this.showResult(false, longMsg || shortMsg || "ì‘ì „ ì‹¤íŒ¨"), 100);
    },
    
    checkGoal(n,p) {
        let ok=true; 
        if(n.props.acceptColor && n.props.acceptColor!==p.colorKey) ok=false; 
        if(n.props.acceptShape && n.props.acceptShape!==p.shape) ok=false;
        if(ok) {
            n.collectedCount++; AudioSys.playTone('success');
            const r = LEVELS.find(l=>l.id===this.level).reward; this.money+=r; this.addEffect(n.x, n.y-20, `+$${r}`, "#ffd700");
            for(let i=0;i<5;i++) this.particles.push(new Particle(n.x+n.w/2, n.y+n.h/2, "#ffd700"));
            this.updateUI();
            const outputs = this.nodes.filter(node=>node.type==='OUTPUT');
            if(outputs.every(node=>node.collectedCount >= node.props.targetCount)) {
                setTimeout(() => { AudioSys.playTone('clear'); this.showResult(true); }, 500);
            }
        } else {
            this.triggerFail(n.x, n.y-20, "ì˜ëª»ëœ ë°ì´í„°!", "ì„œë²„ê°€ ì›í•˜ì§€ ì•ŠëŠ” ë°ì´í„°ê°€ ìœ ì…ë˜ì—ˆìŠµë‹ˆë‹¤.");
        }
    },

    showResult(success, msg) {
        const modal = document.getElementById('result-modal');
        const content = document.getElementById('result-content');
        const title = document.getElementById('result-title');
        const desc = document.getElementById('result-desc');
        const nextBtn = document.getElementById('btn-next-level');
        
        modal.style.display = 'flex';
        content.className = 'modal-content ' + (success ? 'result-win' : 'result-fail');
        title.innerText = success ? "LEVEL CLEAR!" : "MISSION FAILED";
        desc.innerText = msg || (success ? "ëª¨ë“  ë°ì´í„°ê°€ ì™„ë²½í•˜ê²Œ ì²˜ë¦¬ë˜ì—ˆìŠµë‹ˆë‹¤." : "ëª©í‘œ ìˆ˜ëŸ‰ ë¯¸ë‹¬ ë˜ëŠ” ì˜¤ì—¼ ë°œìƒ.");
        nextBtn.style.display = success ? 'inline-block' : 'none';
    },
    closeResult() { document.getElementById('result-modal').style.display='none'; },
    nextLevel() {
        this.closeResult();
        if(this.level < LEVELS.length) this.loadLevel(this.level+1);
        else alert("ğŸ† ëª¨ë“  ë ˆë²¨ì„ ì™„ë£Œí–ˆìŠµë‹ˆë‹¤! ë‹¹ì‹ ì€ ìµœê³ ì˜ ì•„í‚¤í…íŠ¸ì…ë‹ˆë‹¤.");
    },

    addNode(type) {
        if(this.isRunning) return; AudioSys.init();
        const conf=NODE_TYPES[type];
        if(this.currentPower+conf.power > this.maxPower) { this.showToast("ì „ë ¥ ë¶€ì¡±!"); return; }
        const cx = (this.canvas.width/2 - this.camera.x) / this.camera.zoom - 80;
        const cy = (this.canvas.height/2 - this.camera.y) / this.camera.zoom - 40;
        this.nodes.push(new Node(type, cx, cy));
        AudioSys.playTone('click'); this.updateUI();
    },
    sellNode(n) {
        if(n.type==='SOURCE'||n.type==='OUTPUT') return;
        this.nodes=this.nodes.filter(x=>x!==n);
        this.nodes.forEach(x => {
            x.outputs.forEach(portLinks => {
                if (Array.isArray(portLinks)) {
                    for(let i = portLinks.length - 1; i >= 0; i--) {
                        if(portLinks[i].node === n) portLinks.splice(i, 1);
                    }
                }
            });
        });
        AudioSys.playTone('click'); this.updateUI();
    },
    spawnParticles(x,y,c,n) { for(let i=0;i<n;i++) this.particles.push(new Particle(x,y,c)); },
    addEffect(x,y,t,c) { this.effects.push({x,y,text:t,color:c,life:60}); },
    showToast(m) { const t=document.getElementById('toast'); t.innerText=m; t.style.opacity=1; t.style.top="90px"; setTimeout(()=>{t.style.opacity=0; t.style.top="80px";},1500); },
    closeModal() { document.getElementById('mission-modal').style.display='none'; AudioSys.init(); },
    openStore(){document.getElementById('store-modal').style.display='block';this.updateStoreBtn();},
    closeStore(){document.getElementById('store-modal').style.display='none';},
    updateStoreBtn(){
        document.getElementById('btn-up-power').disabled=this.money<UPGRADE_COSTS.POWER;
        document.getElementById('btn-up-speed').disabled=this.money<UPGRADE_COSTS.SPEED;
    },
    buyUpgrade(t) {
        if(t==='POWER'&&this.money>=UPGRADE_COSTS.POWER){this.money-=UPGRADE_COSTS.POWER;this.maxPower+=30;this.showToast("Max Power Up!");}
        else if(t==='SPEED'&&this.money>=UPGRADE_COSTS.SPEED){this.money-=UPGRADE_COSTS.SPEED;this.speedMultiplier+=0.2;this.showToast("CPU Speed Up!");}
        AudioSys.playTone('success'); this.updateUI(); this.updateStoreBtn();
    },
    updateUI() {
        let tw=0; this.nodes.forEach(n=>{if(NODE_TYPES[n.type]) tw+=NODE_TYPES[n.type].power;}); this.currentPower=tw;
        document.getElementById('funds-display').innerText=this.money;
        document.getElementById('power-current').innerText=this.currentPower;
        document.getElementById('power-max').innerText=this.maxPower;
        document.getElementById('cpu-display').innerText=`${this.speedMultiplier.toFixed(1)} GHz`;
        document.getElementById('time-display').innerText = Math.ceil(this.timeLeft)+'s';
        const pct=Math.min(100,(this.currentPower/this.maxPower)*100);
        document.getElementById('power-bar').style.width=pct+'%';
        document.getElementById('power-bar').style.background=pct>90?'#f44':'linear-gradient(90deg, var(--power), #0077ff)';
        
        let c=this.nodes.filter(n=>n.type==='OUTPUT'&&n.collectedCount>=n.props.targetCount).length;
        let t=this.nodes.filter(n=>n.type==='OUTPUT').length;
        document.getElementById('goal-status').innerText=`${c}/${t} Ready`;
    },

    loop(timestamp) {
        const dt = timestamp - this.lastTime;
        this.lastTime = timestamp;
        this.update(dt); 
        this.draw(); 
        requestAnimationFrame(t=>this.loop(t));
    },
    
    update(dt) {
        if(this.isRunning && dt) {
            this.timeLeft -= dt / 1000; 
            if(this.timeLeft <= 0) { this.timeLeft=0; this.showResult(false, "Time Over!"); this.stopSim(); return; }
            document.getElementById('time-display').innerText = Math.ceil(this.timeLeft)+'s';

            this.nodes.forEach(n => n.tick(dt, this.speedMultiplier)); 

            // Packet update with dt
            this.packets.forEach(p=>p.update(dt, this.speedMultiplier));
            this.packets.filter(p=>p.arrived).forEach(p=>p.end.receive(p));
            this.packets=this.packets.filter(p=>!p.arrived);

            // Source Logic
            this.sourceTimer -= dt * this.speedMultiplier;
            if (this.sourceTimer <= 0) {
                this.sourceTimer = 800; 
                let active = false;
                this.nodes.filter(n=>n.type==='SOURCE').forEach(s => {
                    const links = s.outputs[0];
                    links.forEach(link => {
                        if(s.queue.length > 0) { 
                            active=true; 
                            const item=s.queue.shift(); 
                            game.packets.push(new Packet(item.colorKey, item.shape, s, link.node, 0, link.inIdx));
                            AudioSys.playTone('spawn'); 
                        }
                    });
                });
                
                const hasPackets = this.packets.length > 0;
                const hasQueue = this.nodes.some(n => n.inputBuffer && n.inputBuffer.length > 0);
                const sourcesEmpty = this.nodes.filter(n=>n.type==='SOURCE').every(s=>s.queue.length===0);

                if(sourcesEmpty && !active && !hasPackets && !hasQueue) { setTimeout(()=>this.checkResult(), 1500); }
            }
        }
        this.effects.forEach(e=>{e.y-=0.5;e.life--;}); this.effects=this.effects.filter(e=>e.life>0);
        this.particles.forEach(p=>{p.x+=p.vx;p.y+=p.vy;p.life--;p.size*=0.95;}); this.particles=this.particles.filter(p=>p.life>0);
        
        const tooltip = document.getElementById('tooltip');
        if(this.mouse) {
             const worldPos = this.screenToWorld(this.mouse.x, this.mouse.y);
             let hovered = false;
             for(let i=this.nodes.length-1; i>=0; i--) {
                const n = this.nodes[i];
                if(worldPos.x >= n.x && worldPos.x <= n.x+n.w && worldPos.y >= n.y && worldPos.y <= n.y+n.h) {
                    tooltip.style.display = 'block';
                    tooltip.style.left = (this.mouse.x + 15) + 'px';
                    tooltip.style.top = (this.mouse.y + 15) + 'px';
                    
                    let txt = NODE_TYPES[n.type] ? NODE_TYPES[n.type].desc : n.name;
                    if(n.type==='FILTER' || n.type==='SHAPE_SORTER' || n.type==='PERCEPTRON') {
                         txt += `\nTarget: ${n.props.filterColor || n.props.targetShape || n.props.targetColor}`;
                         txt += "\n(Click to Change)";
                    }
                    if(n.type==='PERCEPTRON') {
                        txt += `\nTraining: ${Math.floor(n.state.accuracy*100)}%`;
                    }
                    tooltip.innerText = txt;
                    hovered = true;
                    break;
                }
             }
             if(!hovered) tooltip.style.display = 'none';
        }
    },
    
    screenToWorld(sx, sy) { return { x: (sx - this.camera.x) / this.camera.zoom, y: (sy - this.camera.y) / this.camera.zoom }; },
    worldToScreen(wx, wy) { return { x: wx * this.camera.zoom + this.camera.x, y: wy * this.camera.zoom + this.camera.y }; },

    draw() {
        const ctx = this.ctx;
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        ctx.save();
        ctx.translate(this.camera.x, this.camera.y);
        ctx.scale(this.camera.zoom, this.camera.zoom);
        
        const gridSize = 40;
        const left = -this.camera.x / this.camera.zoom;
        const top = -this.camera.y / this.camera.zoom;
        const right = left + this.canvas.width / this.camera.zoom;
        const bottom = top + this.canvas.height / this.camera.zoom;
        
        ctx.strokeStyle = 'rgba(255,255,255,0.05)'; ctx.lineWidth = 1; ctx.beginPath();
        for (let x = Math.floor(left / gridSize) * gridSize; x <= right; x += gridSize) { ctx.moveTo(x, top); ctx.lineTo(x, bottom); }
        for (let y = Math.floor(top / gridSize) * gridSize; y <= bottom; y += gridSize) { ctx.moveTo(left, y); ctx.lineTo(right, y); }
        ctx.stroke();

        this.nodes.forEach(n => {
            n.outputs.forEach((links,i) => {
                links.forEach(l => {
                    if(l) {
                        const s = n.getOutPos(i); const e = l.node.getInPos(l.inIdx);
                        ctx.beginPath(); ctx.moveTo(s.x, s.y);
                        const cp1x = s.x + Math.abs(e.x-s.x)*0.5;
                        ctx.bezierCurveTo(cp1x, s.y, cp1x, e.y, e.x, e.y);
                        ctx.strokeStyle='#555'; ctx.lineWidth=3; ctx.stroke();
                    }
                });
            });
        });
        if(this.wireStart) {
            const s=this.wireStart.node.getOutPos(this.wireStart.idx);
            const m = this.screenToWorld(this.mouse.x, this.mouse.y);
            ctx.beginPath(); ctx.moveTo(s.x,s.y); ctx.lineTo(m.x, m.y);
            ctx.strokeStyle='#fff'; ctx.setLineDash([5,5]); ctx.stroke(); ctx.setLineDash([]);
        }

        this.nodes.forEach(n => n.draw(ctx));
        this.packets.forEach(p => p.draw(ctx));
        this.particles.forEach(p => { ctx.globalAlpha = p.life/p.max; ctx.fillStyle=p.c; ctx.beginPath(); ctx.arc(p.x,p.y,p.size,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1.0; });
        this.effects.forEach(e => { ctx.globalAlpha = e.life/60; ctx.fillStyle=e.color; ctx.font='bold 14px Consolas'; ctx.fillText(e.text, e.x, e.y); ctx.globalAlpha=1.0; });
        ctx.restore();
    },

    setupInput() {
        const cvs = this.canvas;
        let dragNode = null;
        let isDragging = false; 

        const handleStart = (clientX, clientY) => {
            const rect = cvs.getBoundingClientRect();
            const mx = clientX - rect.left;
            const my = clientY - rect.top;
            const worldPos = this.screenToWorld(mx, my);
            AudioSys.init();
            
            isDragging = false;

            if(this.isRunning) {
                this.isPanning = true; this.panStart = { x: mx, y: my };
                return;
            }

            for(let n of this.nodes) {
                for(let i=0; i<n.outputs.length; i++) {
                    const p = n.getOutPos(i);
                    if(Math.hypot(p.x - worldPos.x, p.y - worldPos.y) < 20) {
                        this.wireStart = { node:n, idx:i }; 
                        return;
                    }
                }
            }
            for(let i=this.nodes.length-1; i>=0; i--) {
                const n = this.nodes[i];
                if(worldPos.x >= n.x && worldPos.x <= n.x+n.w && worldPos.y >= n.y && worldPos.y <= n.y+n.h) {
                    dragNode = n; return;
                }
            }
            this.isPanning = true; this.panStart = { x: mx, y: my };
        };

        const handleMove = (clientX, clientY) => {
            const rect = cvs.getBoundingClientRect();
            const mx = clientX - rect.left;
            const my = clientY - rect.top;
            this.mouse = { x: mx, y: my };
            const worldPos = this.screenToWorld(mx, my);

            if (this.isPanning) {
                const dx = mx - this.panStart.x;
                const dy = my - this.panStart.y;
                if(Math.abs(dx)>2 || Math.abs(dy)>2) isDragging = true;
                this.camera.x += dx;
                this.camera.y += dy;
                this.panStart = { x: mx, y: my };
            } else if (dragNode) {
                isDragging = true;
                dragNode.x = worldPos.x - dragNode.w/2;
                dragNode.y = worldPos.y - dragNode.h/2;
            }
        };

        const handleEnd = (clientX, clientY) => {
            if(this.wireStart) {
                const rect = cvs.getBoundingClientRect();
                const mx = clientX - rect.left;
                const my = clientY - rect.top;
                const worldPos = this.screenToWorld(mx, my);
                
                for(let n of this.nodes) {
                    for(let i=0; i<n.inputs.length; i++) {
                        const p = n.getInPos(i);
                        if(Math.hypot(p.x - worldPos.x, p.y - worldPos.y) < 20) {
                            // Connection Validator
                            let isOccupied = false;
                            if(n.type !== 'OUTPUT' && n.type !== 'TRASH') {
                                for(let otherNode of this.nodes) {
                                    otherNode.outputs.forEach(links => {
                                        if(links.some(l => l.node === n && l.inIdx === i)) isOccupied = true;
                                    });
                                }
                            }

                            if(!isOccupied && n !== this.wireStart.node) {
                                this.wireStart.node.outputs[this.wireStart.idx].push({ node:n, inIdx:i });
                                AudioSys.playTone('click');
                            } else {
                                AudioSys.playTone('fail');
                            }
                        }
                    }
                }
                this.wireStart = null;
            }
            else if (dragNode && !isDragging) {
                if(dragNode.type === 'FILTER' || dragNode.type === 'SHAPE_SORTER' || dragNode.type === 'PERCEPTRON') {
                    dragNode.toggleConfig();
                    AudioSys.playTone('click');
                }
            }
            dragNode = null;
            this.isPanning = false;
            this.lastPinchDist = 0;
        };

        cvs.addEventListener('mousedown', e => { if(e.button===0) handleStart(e.clientX, e.clientY); });
        cvs.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));
        cvs.addEventListener('mouseup', e => handleEnd(e.clientX, e.clientY));

        cvs.addEventListener('touchstart', e => {
            if(e.touches.length === 1) {
                handleStart(e.touches[0].clientX, e.touches[0].clientY);
            } else if (e.touches.length === 2) {
                this.isPanning = false; dragNode = null; this.wireStart = null; 
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                this.lastPinchDist = Math.hypot(dx, dy);
            }
        }, {passive: false});

        cvs.addEventListener('touchmove', e => {
            if(e.touches.length === 1) {
                handleMove(e.touches[0].clientX, e.touches[0].clientY);
            } else if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const dist = Math.hypot(dx, dy);
                
                if (this.lastPinchDist > 0) {
                    const zoomFactor = dist / this.lastPinchDist;
                    const cx = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                    const cy = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                    const rect = cvs.getBoundingClientRect();
                    const mx = cx - rect.left;
                    const my = cy - rect.top;

                    const worldPosBefore = this.screenToWorld(mx, my);
                    this.camera.zoom *= zoomFactor;
                    this.camera.zoom = Math.max(0.2, Math.min(3, this.camera.zoom));
                    const worldPosAfter = this.screenToWorld(mx, my);
                    this.camera.x += (worldPosAfter.x - worldPosBefore.x) * this.camera.zoom;
                    this.camera.y += (worldPosAfter.y - worldPosBefore.y) * this.camera.zoom;
                }
                this.lastPinchDist = dist;
            }
            e.preventDefault(); 
        }, {passive: false});

        cvs.addEventListener('touchend', e => {
            const touch = e.changedTouches[0];
            handleEnd(touch.clientX, touch.clientY);
        });

        cvs.addEventListener('wheel', e => {
            e.preventDefault();
            const zoomSensitivity = 0.001;
            const zoomFactor = Math.exp(e.deltaY * -zoomSensitivity);
            const mx = e.offsetX, my = e.offsetY;
            const worldPosBefore = this.screenToWorld(mx, my);
            this.camera.zoom *= zoomFactor;
            this.camera.zoom = Math.max(0.1, Math.min(5, this.camera.zoom));
            const worldPosAfter = this.screenToWorld(mx, my);
            this.camera.x += (worldPosAfter.x - worldPosBefore.x) * this.camera.zoom;
            this.camera.y += (worldPosAfter.y - worldPosBefore.y) * this.camera.zoom;
        });

        cvs.addEventListener('contextmenu', e => {
            e.preventDefault();
            if(this.isRunning) return;
            const mx = e.offsetX, my = e.offsetY;
            const worldPos = this.screenToWorld(mx, my);
            for(let i=this.nodes.length-1; i>=0; i--) {
                const n = this.nodes[i];
                if(worldPos.x >= n.x && worldPos.x <= n.x+n.w && worldPos.y >= n.y && worldPos.y <= n.y+n.h) {
                    this.sellNode(n); return;
                }
            }
        });
    }
};

game.init();
</script>
</body>
</html>
